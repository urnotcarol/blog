{"meta":{"title":"Carol的博客","subtitle":null,"description":null,"author":"Carolunar","url":"//carolunar.com"},"pages":[{"title":"标签","date":"2017-12-10T06:47:36.000Z","updated":"2017-12-10T06:50:02.807Z","comments":true,"path":"tags/index.html","permalink":"//carolunar.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2017-12-10T06:48:19.000Z","updated":"2017-12-10T06:49:44.848Z","comments":true,"path":"categories/index.html","permalink":"//carolunar.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Spark统计莎士比亚文集词频大容量版","slug":"spark-shakespeare","date":"2017-07-08T03:06:28.000Z","updated":"2017-12-10T07:07:41.467Z","comments":true,"path":"2017/07/08/spark-shakespeare/","link":"","permalink":"//carolunar.com/2017/07/08/spark-shakespeare/","excerpt":"题目要求输入 莎士比亚文集，存放在HDFS上的一个文件目录下面 停词表：与scala目录同级的一个resources目录下 输出 所有文集中空行的总数 出现次数前100的单词","text":"题目要求输入 莎士比亚文集，存放在HDFS上的一个文件目录下面 停词表：与scala目录同级的一个resources目录下 输出 所有文集中空行的总数 出现次数前100的单词 注意：不能上传停词表到HDFS上 数据预处理源文件是一个一个100KB左右的小文件，经过批量复制一共9000多个，如果在处理时依次读取，会花费大量不必要的时间，因此先对其进行处理，合并成一个大文件，放在hdfs上。 文件合并思路使用JAVA操作hdfs的API，读取本地指定目录下所有的文件，依次追加到集群上某一个文件中。相当于代替hdfs shell的appendToFile操作。 合并代码123456789101112131415161718192021//HDFSWriter.javapublic class HDFSWriter &#123; public static void main(String[] args) throws Exception &#123; Configuration conf = new Configuration(); conf.setBoolean(\"dfs.support.append\", true); File fileDir = new File(args[0]); File[] fileList = fileDir.listFiles(); String hdfsPath = args[1]; FileSystem hdfs = FileSystem.get(URI.create(hdfsPath), conf); OutputStream out = hdfs.append(new Path(hdfsPath)); for (int i = 0; i &lt; fileList.length; i++) &#123; InputStream in = new BufferedInputStream(new FileInputStream(fileList[i])); IOUtils.copyBytes(in, out, 4096, false); //第四个参数含义为是否在复制完毕后关闭io流 in.close(); &#125; out.close(); &#125;&#125; 执行过程打成JAR之后，用hadoop jar运行1hadoop jar /home/hadoop/bigdata-hadoop-mr1-1.jar cn.youe.hdfs.HDFSWriter /home/hadoop/shakespeare merged.txt 运行完毕后，集群上出现了1.1G的合并后的文件12[root@hdp-node-02 hadoop]# hdfs dfs -ls -h /-rw-r--r-- 1 root supergroup 1.1 G 2017-06-28 20:52 /merged.txt 至此，数据预处理完毕，对merged.txt进行词频统计 分析数据按行读入，先统计空行个数，同时将每一行分割成单词的集合。再过滤掉停词，进行词频统计。 源码12345678910111213141516171819202122232425262728293031323334353637383940414243import org.apache.spark.&#123;SparkConf, SparkContext&#125;object WSWorkCount &#123; def main(args: Array[String]): Unit = &#123; //args(0)是输入文件，args(1)是总输出路径 val startTime = System.currentTimeMillis() val src = args(0) val outPath = args(1) val spaceOutPath = outPath + \"/spaceout\" val countOutPath = outPath + \"/wordout\" val conf = new SparkConf().setAppName(\"WSWorkCount\") val sc = new SparkContext(conf) val lines = sc.textFile(src) val sum = sc.accumulator(0, \"spaceCount\") val words = lines.flatMap(line =&gt; &#123; if (line.trim().length() == 0) sum += 1 \"[a-zA-Z]+\".r.findAllIn(line).map(word =&gt; (word.toLowerCase(), 1)) &#125;) //滤掉停用词 val stopWords = sc.broadcast(scala.io.Source.fromInputStream(getClass.getResourceAsStream(\"/stopwords.txt\")).getLines.map(_.trim()).toSet) val goodWords = words.filter(word =&gt; &#123; !stopWords.value.contains(word._1) &#125;) //统计前100 val firstHundred = goodWords.reduceByKey(_ + _).sortBy(_._2, false).take(100) val res = sc.parallelize(firstHundred) res.saveAsTextFile(countOutPath) //输出空格数 val spaceRes = sc.parallelize(sum.toString()) spaceRes.saveAsTextFile(spaceOutPath) val endTime = System.currentTimeMillis() val runTime = (endTime - startTime) / 1000 val timeOutPath = outPath + \"/\" + runTime.toString() val timeRes = sc.parallelize(runTime.toString()) timeRes.saveAsTextFile(timeOutPath) &#125;&#125; 在集群运行12345678/usr/local/apps/spark-1.6.0-bin-hadoop2.6/bin/spark-submit \\--class WSWorkCount \\--master spark://hdp-node-01:7077 \\--executor-memory 512M \\--total-executor-cores 4 \\/home/hadoop/scalabase.jar \\hdfs://hdp-node-01:9000/merged.txt \\hdfs://hdp-node-01:9000/out05 主要优化思路 统计空行数量的变量sum设置为累加器 stopWords设置为广播变量 减少一个map stopWords存储结构使用Set而非Array，查询效率更高 不用合并文件的方法设置hdfs分割文件的大小，使程序可以一次读取大量内容而非按照文件依次去读，这样省去了文件合并的步骤，同时时间也很短。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import org.apache.hadoop.io.&#123;LongWritable, Text&#125;import org.apache.hadoop.mapreduce.lib.input.CombineTextInputFormatimport org.apache.log4j.&#123;Level, Logger&#125;import org.apache.spark.&#123;SparkConf, SparkContext&#125;object WSLocal &#123; def main(args: Array[String]): Unit = &#123; Logger.getLogger(\"org.apache.spark\").setLevel(Level.ERROR) Logger.getLogger(\"org.eclipse.jetty.server\").setLevel(Level.ERROR) // args(0)是输入文件，args(1)是总输出路径 val src = \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\merged1\" val outPath = \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\localOut40\" val spaceOutPath = outPath + \"\\\\spaceOut\" val countOutPath = outPath + \"\\\\wordOut\" val startTime = System.currentTimeMillis() val conf = new SparkConf().setAppName(\"WSLocal\").setMaster(\"local\") val sc = new SparkContext(conf) sc.hadoopConfiguration.setLong(\"mapreduce.input.fileformat.split.maxsize\", 20000000) val lines = sc.newAPIHadoopFile(src, classOf[CombineTextInputFormat], classOf[LongWritable], classOf[Text]).map(_._2.toString)// 用上面两行代替这一行// val lines = sc.textFile(src) //lines是一个集合，每个元素是源文件中的一行 val sum = sc.accumulator(0, \"spaceCount\") val words = lines.flatMap(line =&gt; &#123; if (line.length() == 0)&#123; sum += 1 &#125; \"[a-zA-Z]+\".r.findAllIn(line).map(word =&gt; (word.toLowerCase(), 1)) &#125;) //滤掉停用词 val stopWords = sc.broadcast(scala.io.Source.fromInputStream(getClass.getResourceAsStream(\"/stopwords.txt\")).getLines.map(_.trim()).toSet) val goodWords = words.filter(word =&gt; &#123; !stopWords.value.contains(word._1) &#125;) //统计前100 val firstHundred = goodWords.reduceByKey(_ + _).sortBy(_._2, false).take(100) val res = sc.parallelize(firstHundred) res.saveAsTextFile(countOutPath) //输出空格数 val spaceRes = sc.parallelize(sum.toString()) spaceRes.saveAsTextFile(spaceOutPath) val endTime = System.currentTimeMillis() val runTime = (endTime - startTime) / 1000 val timeOutPath = outPath + \"\\\\\" + runTime.toString() val timeRes = sc.parallelize(runTime.toString) timeRes.saveAsTextFile(timeOutPath) &#125;&#125;","categories":[],"tags":[{"name":"spark","slug":"spark","permalink":"//carolunar.com/tags/spark/"}]},{"title":"Hadoop练习-流量统计","slug":"hadoop-exp-flow-calc","date":"2017-06-22T13:04:17.000Z","updated":"2017-12-09T15:33:26.960Z","comments":true,"path":"2017/06/22/hadoop-exp-flow-calc/","link":"","permalink":"//carolunar.com/2017/06/22/hadoop-exp-flow-calc/","excerpt":"要求 统计出每个手机号的上行流量、下行流量和总流量。 将所得结果按照总流量倒序排序。 将结果按照手机归属地不同（根据号码前缀判断）设置不同的分区。 思路 map阶段预处理数据，手机号作为key，使用自定义的类封装value，包含三个流量值。reduce阶段将同一手机号的流量和统计出来。 map阶段将key和value交换，在value的类中重写compareTo函数，按照总流量倒序排。","text":"要求 统计出每个手机号的上行流量、下行流量和总流量。 将所得结果按照总流量倒序排序。 将结果按照手机归属地不同（根据号码前缀判断）设置不同的分区。 思路 map阶段预处理数据，手机号作为key，使用自定义的类封装value，包含三个流量值。reduce阶段将同一手机号的流量和统计出来。 map阶段将key和value交换，在value的类中重写compareTo函数，按照总流量倒序排。 设置分类器，根据手机号前缀来映射到不同的分区（并不知道实际归属的情况，这里假设134-139开头各映射到一个分区，其余统一映射到一个分区）。使得map阶段的数据在到达reduce阶段之前就到了不同的分区，会有个数等于分区数的reduce任务被执行。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221package cn.youe.flowcalc;import org.apache.hadoop.fs.Path;import org.apache.hadoop.io.*;import org.apache.hadoop.mapreduce.Job;import org.apache.hadoop.mapreduce.Mapper;import org.apache.hadoop.mapreduce.Partitioner;import org.apache.hadoop.mapreduce.Reducer;import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;import java.io.DataInput;import java.io.DataOutput;import java.io.IOException;/** * Created by Carol on 2017/6/21. */public class FlowCalcDriver &#123; static class Flow implements WritableComparable &#123; int upFlow = 0; int downFlow = 0; int totalFlow = 0; public int getUpFlow() &#123; return upFlow; &#125; public void setUpFlow(int upFlow) &#123; this.upFlow = upFlow; &#125; public int getDownFlow() &#123; return downFlow; &#125; public void setDownFlow(int downFlow) &#123; this.downFlow = downFlow; &#125; public int getTotalFlow() &#123; return totalFlow; &#125; public void setTotalFlow(int totalFlow) &#123; this.totalFlow = totalFlow; &#125; public void set(int upFlow, int downFlow, int totalFlow) &#123; this.upFlow = upFlow; this.downFlow = downFlow; this.totalFlow = totalFlow; &#125; public void write(DataOutput out) throws IOException &#123; out.writeInt(this.upFlow); out.writeInt(this.downFlow); out.writeInt(this.totalFlow); &#125; public void readFields(DataInput in) throws IOException &#123; this.upFlow = in.readInt(); this.downFlow = in.readInt(); this.totalFlow = in.readInt(); &#125; @Override public String toString() &#123; return this.upFlow + \"\\t\" + this.downFlow + \"\\t\" + this.totalFlow; &#125; public int compareTo(Flow that) &#123; return this.totalFlow &amp;gt; that.getTotalFlow() ? -1 : 1; &#125; &#125; static class FlowCalcMapper extends Mapper&lt;LongWritable, Text, Text, Flow&gt; &#123; Text text = new Text(); Flow flow = new Flow(); @Override protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException &#123; String[] fields = value.toString().split(\"\\t\"); int upFlow = Integer.parseInt(fields[fields.length - 3]); int downFlow = Integer.parseInt(fields[fields.length - 2]); int totalFlow = upFlow + downFlow; text.set(fields[1]); //不会出现指向同一个数据的问题 flow.set(upFlow, downFlow, totalFlow); context.write(text, flow); &#125; &#125; static class FlowCalcReducer extends Reducer&lt;Text, Flow, Text, Flow&gt; &#123; protected void reduce(Text key, Iterable&lt;Flow&gt; values, Context context) throws IOException, InterruptedException &#123; Flow flow = new Flow(); for (Flow value:values) &#123; flow.setUpFlow(flow.getUpFlow() + value.upFlow); flow.setDownFlow(flow.getDownFlow() + value.getDownFlow()); flow.setTotalFlow(flow.getTotalFlow() + value.getTotalFlow()); &#125; context.write(key, flow); &#125; &#125; static class FlowSortMapper extends Mapper&lt;LongWritable, Text, Flow, Text&gt; &#123; Text text = new Text(); Flow flow = new Flow(); @Override protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException &#123; String fields[] = value.toString().split(\"\\t\"); text.set(fields[0]); flow.set(Integer.parseInt(fields[1]), Integer.parseInt(fields[2]), Integer.parseInt(fields[3])); context.write(flow, text); //交换key和value，flow作为key，手机号码作为value。以达到对总流量排序的目的。 &#125; &#125; static class FlowSortReducer extends Reducer&lt;Flow, Text, Text, Flow&gt; &#123; protected void reduce(Flow key, Iterable&lt;Text&gt; values, Context context) throws IOException, InterruptedException &#123; for (Text value:values) &#123; context.write(value, key); &#125; &#125; &#125; static class phonePartitioner extends Partitioner&lt;Flow, Text&gt; &#123; @Override public int getPartition(Flow key, Text value, int num) &#123; int res; int prefix = Integer.parseInt(value.toString().substring(0, 3)); if (prefix &amp;gt;= 134 &amp;amp;&amp;amp; prefix &amp;lt;= 139) &#123; res = prefix % 134; &#125; else &#123; res = 6; &#125; return res; &#125; &#125; static class FlowPartitionMapper extends Mapper&lt;LongWritable, Text, Flow, Text&gt; &#123; Text text = new Text(); Flow flow = new Flow(); @Override protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException &#123; String fields[] = value.toString().split(\"\\t\"); text.set(fields[0]); flow.set(Integer.parseInt(fields[1]), Integer.parseInt(fields[2]), Integer.parseInt(fields[3])); context.write(flow, text); &#125; &#125; static class FlowPartitionReducer extends Reducer&lt;Flow, Text, Text, Flow&gt; &#123; @Override protected void reduce(Flow key, Iterable&lt;Text&gt; values, Context context) throws IOException, InterruptedException &#123; for (Text value:values) &#123; context.write(value, key); &#125; &#125; &#125; public static void main(String[] args) throws Exception &#123; //第一个任务，统计总流量 Job job = Job.getInstance(); job.setJarByClass(FlowCalcDriver.class); job.setMapperClass(FlowCalcMapper.class); job.setReducerClass(FlowCalcReducer.class); job.setMapOutputKeyClass(Text.class); job.setMapOutputValueClass(Flow.class); job.setOutputKeyClass(Text.class); job.setOutputValueClass(Flow.class); FileInputFormat.addInputPath(job, new Path(args[0])); FileOutputFormat.setOutputPath(job, new Path(args[1])); boolean flag = job.waitForCompletion(true); //第二个任务，总流量倒序输出 Job sortJob = Job.getInstance(); sortJob.setJarByClass(FlowCalcDriver.class); sortJob.setMapperClass(FlowSortMapper.class); sortJob.setReducerClass(FlowSortReducer.class); sortJob.setMapOutputKeyClass(Flow.class); sortJob.setMapOutputValueClass(Text.class); sortJob.setOutputKeyClass(Text.class); sortJob.setOutputValueClass(Flow.class); FileInputFormat.addInputPath(sortJob, new Path(args[1])); FileOutputFormat.setOutputPath(sortJob, new Path(args[2])); boolean sortFlag = sortJob.waitForCompletion(true); //第三个任务，按手机号前缀分区 Job partJob = Job.getInstance(); partJob.setJarByClass(FlowCalcDriver.class); partJob.setMapperClass(FlowPartitionMapper.class); partJob.setReducerClass(FlowPartitionReducer.class); partJob.setMapOutputKeyClass(Flow.class); partJob.setMapOutputValueClass(Text.class); partJob.setOutputKeyClass(Text.class); partJob.setOutputValueClass(Flow.class); partJob.setPartitionerClass(phonePartitioner.class); partJob.setNumReduceTasks(7); FileInputFormat.addInputPath(partJob, new Path(args[2])); FileOutputFormat.setOutputPath(partJob, new Path(args[3])); boolean partFlag = partJob.waitForCompletion(true); System.exit((flag == true &amp;amp;&amp;amp; sortFlag == true &amp;amp;&amp;amp; partFlag == true)? 1:0); &#125;&#125;","categories":[],"tags":[{"name":"Hadoop","slug":"Hadoop","permalink":"//carolunar.com/tags/Hadoop/"}]},{"title":"AOJ 0121 Seven Puzzle 题解 BFS + 康托展开","slug":"aoj-0121-seven-puzzle","date":"2017-04-17T08:21:34.000Z","updated":"2017-12-09T19:56:57.140Z","comments":true,"path":"2017/04/17/aoj-0121-seven-puzzle/","link":"","permalink":"//carolunar.com/2017/04/17/aoj-0121-seven-puzzle/","excerpt":"AOJ 0121 Seven Puzzle 题意4 * 2 的方格，填充了 0 - 7 这八个数字。相邻格子可以交换内容。给定任意一组序列，求最少多少次交换可以使其变成顺序排列。 思路BFS + 康托展开判重。是迷宫类问题的升级版，升级之处在于是一个动态的地图，每次搜索都会改变它，因此不能用单一变量来表示地图。 所以每次入队的不是移动对象当前走到了哪里，而是一整张地图的状态。 可以用康托展开+数组判重，也可以用别的 hash 函数配合 STL 的 map使用，后者就不要求映射后在尽量小的范围内了。 另外一种判重的方法，是根本不展开，把一整个地图当做字符串处理，这样由于字符串本身的连续性以及相互之间的相异性，可以配合 map 轻松地判重~","text":"AOJ 0121 Seven Puzzle 题意4 * 2 的方格，填充了 0 - 7 这八个数字。相邻格子可以交换内容。给定任意一组序列，求最少多少次交换可以使其变成顺序排列。 思路BFS + 康托展开判重。是迷宫类问题的升级版，升级之处在于是一个动态的地图，每次搜索都会改变它，因此不能用单一变量来表示地图。 所以每次入队的不是移动对象当前走到了哪里，而是一整张地图的状态。 可以用康托展开+数组判重，也可以用别的 hash 函数配合 STL 的 map使用，后者就不要求映射后在尽量小的范围内了。 另外一种判重的方法，是根本不展开，把一整个地图当做字符串处理，这样由于字符串本身的连续性以及相互之间的相异性，可以配合 map 轻松地判重~ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;queue&gt;using namespace std;const int MAX_S = 40320 + 16;const int INF = 0x3f3f3f3f;int fact[10] = &#123;1, 1, 2, 6, 24, 120, 720, 5040, 40320&#125;;int a[16];int n = 7;int dp[MAX_S];struct State &#123; int a[16]; int pos; int contor() &#123; //康托展开，返回特定序列所对应的整数 int res = 0; for (int i = 0; i &lt;= n; i++) &#123; int count = 0; for (int j = i + 1; j &lt;= n; j++) &#123; if (a[j] &lt; a[i]) &#123; count++; &#125; &#125; res += count * fact[n - i]; &#125; return res; &#125;&#125;;int dx[4] = &#123;1, -1, 4, -4&#125;;void bfs() &#123; State ini; for (int i = 0; i &lt;= n; i++) &#123; ini.a[i] = i; &#125; ini.pos = 0; queue&lt;State&gt; que; que.push(ini); dp[0] = 0; while(!que.empty()) &#123; State cur = que.front(); que.pop(); for (int i = 0; i &lt; 4; i++) &#123; int p = cur.pos + dx[i]; if (p &gt;= 0 &amp;amp;&amp;amp; p &lt;= 7 &amp;amp;&amp;amp; !(cur.pos == 3 &amp;amp;&amp;amp; p == 4) &amp;amp;&amp;amp; !(cur.pos == 4 &amp;amp;&amp;amp; p == 3)) &#123; State next = cur; swap(next.a[p], next.a[cur.pos]); next.pos = p; int contorH = next.contor(); if (dp[contorH] == INF) &#123; dp[contorH] = dp[cur.contor()] + 1; que.push(next); &#125; &#125; &#125; &#125;&#125;int main() &#123; fill(dp, dp + MAX_S, INF); string line; bfs(); while(getline(cin, line)) &#123; State cur; for (int i = 0; i &lt;= n; i++) &#123; cur.a[i] = line[2 * i] - '0'; &#125; printf(\"%d\\n\", dp[cur.contor()]); &#125;&#125; PS，第八届蓝桥杯省赛第二道填空题跳蚂蚱和这道题很像。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;queue&gt;#include &lt;memory.h&gt;using namespace std;const int MAX_S = 362880 + 16;int fact[10] = &#123;1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880&#125;;int dx[4] = &#123;-2, -1, 1, 2&#125;;bool visited[MAX_S];int n = 8;struct State &#123; int a[21]; int pos; int step; bool isAns() &#123; bool res = true; for (int i = 1; i &lt;= n; i++) &#123; if (a[i] != (n + 1 - i)) &#123; res = false; break; &#125; &#125; return res; &#125; int contor() &#123; int res = 0; for (int i = 0; i &lt;= n; i++) &#123; int count = 0; for (int j = i + 1; j &lt;= n; j++) &#123; if (a[j] &lt; a[i]) &#123; count++; &#125; &#125; res += fact[n - i] * count; &#125; return res; &#125;&#125;;void bfs() &#123; fill(visited, visited + MAX_S, false); State ini; for (int i = 0; i &lt;= n; i++) &#123; ini.a[i] = i; &#125; ini.pos = 0; ini.step = 0; queue&lt;State&gt; que; que.push(ini); while(!que.empty()) &#123; State cur = que.front(); que.pop(); int contorH = cur.contor(); if (visited[contorH]) &#123; continue; &#125; visited[contorH] = true; if (cur.isAns()) &#123; printf(\"%d\", cur.step); break; &#125; for (int i = 0; i &lt; 4; i++) &#123; State next = cur; int x = next.pos; int y = (next.pos + dx[i] + n + 1) % (n + 1); swap(next.a[x], next.a[y]); next.pos = y; next.step++; que.push(next); &#125; &#125;&#125;int main() &#123; bfs(); return 0;&#125; 参考码农场 » AOJ 0121: Seven Puzzle 《挑战程序设计竞赛(第2版)》练习题答案 大圣给的题解","categories":[{"name":"算法","slug":"算法","permalink":"//carolunar.com/categories/算法/"}],"tags":[{"name":"BFS OJ","slug":"BFS-OJ","permalink":"//carolunar.com/tags/BFS-OJ/"}]},{"title":"蓝桥杯 ADV232 矩阵乘法 题解 区间DP","slug":"lanqiao-adv232-matrix-chain-multiplication","date":"2017-04-05T03:13:29.000Z","updated":"2017-12-09T15:33:26.956Z","comments":true,"path":"2017/04/05/lanqiao-adv232-matrix-chain-multiplication/","link":"","permalink":"//carolunar.com/2017/04/05/lanqiao-adv232-matrix-chain-multiplication/","excerpt":"题目有n个矩阵，大小分别为a0*a1, a1*a2, a2*a3, …, a[n-1]*a[n]，现要将它们依次相乘，只能使用结合率，求最少需要多少次运算。 两个大小分别为p*q和q*r的矩阵相乘时的运算次数计为p*q*r。","text":"题目有n个矩阵，大小分别为a0*a1, a1*a2, a2*a3, …, a[n-1]*a[n]，现要将它们依次相乘，只能使用结合率，求最少需要多少次运算。 两个大小分别为p*q和q*r的矩阵相乘时的运算次数计为p*q*r。 输入输入的第一行包含一个整数n，表示矩阵的个数。第二行包含n+1个数，表示给定的矩阵。 3 1 10 5 20 数据规模和约定 1&lt;=n&lt;=1000, 1&lt;=ai&lt;=10000 思路经典的石子合并问题，《算法导论》动态规划这一章有非非非常详细的讲解。以前没有做过这种 DP 题。 代码有三层循环，第一层 l 表示合并的堆数，从 2 到 n，代表从两堆到三堆到四堆…逐渐推出合并所有需要的代价。 第二层 i 表示合并的起始序号，相应的 j 就表示结束序号。 第三层 k 表示从 i 遍历到 j，找出最优的分割点。 代码12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;limits.h&gt;#define ONLINE_JUDGEusing namespace std;const int MAX_N = 1000 + 16;const long long INF = LLONG_MAX; //LLONG_MAX 定义在头文件 &lt;limits.h&gt; 中int n;long long dp[MAX_N][MAX_N];long long p[MAX_N];int main() &#123; #ifndef ONLINE_JUDGE freopen(\"in.txt\", \"r\", stdin); #endif scanf(\"%d\", &amp;n); for (int i = 0; i &lt;= n; i++) &#123; scanf(\"%lld\", &amp;p[i]); &#125; for (int i = 1; i &lt;= n; i++) &#123; dp[i][i] = 0; &#125; for (int l = 2; l &lt;= n; l++) &#123; for (int i = 1; i &lt;= n - l + 1; i++) &#123; int j = i + l - 1; dp[i][j] = INF; for (int k = i; k &lt; j; k++) &#123; dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + p[i - 1] * p[k] * p[j]); &#125; &#125; &#125; #ifndef ONLINE_JUDGE fclose(stdin); #endif printf(\"%lld\\n\", dp[1][n]); return 0;&#125; 知识水平头文件&lt;limits.h&gt;是个好文件，里面包含了各种变量的范围，当不需要对最大值最小值进行相加操作时（不会溢出），可以用这个里面的定义。","categories":[],"tags":[{"name":"动态规划 区间DP","slug":"动态规划-区间DP","permalink":"//carolunar.com/tags/动态规划-区间DP/"}]},{"title":"CCF 201703-4 地铁修建 题解 并查集","slug":"ccf-201703-4-construct-subway","date":"2017-04-05T02:43:44.000Z","updated":"2017-12-09T15:33:26.969Z","comments":true,"path":"2017/04/05/ccf-201703-4-construct-subway/","link":"","permalink":"//carolunar.com/2017/04/05/ccf-201703-4-construct-subway/","excerpt":"题目A市有n个交通枢纽，其中1号和n号非常重要，为了加强运输能力，A市决定在1号到n号枢纽间修建一条地铁。 地铁由很多段隧道组成，每段隧道连接两个交通枢纽。经过勘探，有m段隧道作为候选，两个交通枢纽之间最多只有一条候选的隧道，没有隧道两端连接着同一个交通枢纽。 现在有n家隧道施工的公司，每段候选的隧道只能由一个公司施工，每家公司施工需要的天数一致。而每家公司最多只能修建一条候选隧道。所有公司同时开始施工。 作为项目负责人，你获得了候选隧道的信息，现在你可以按自己的想法选择一部分隧道进行施工，请问修建整条地铁最少需要多少天。","text":"题目A市有n个交通枢纽，其中1号和n号非常重要，为了加强运输能力，A市决定在1号到n号枢纽间修建一条地铁。 地铁由很多段隧道组成，每段隧道连接两个交通枢纽。经过勘探，有m段隧道作为候选，两个交通枢纽之间最多只有一条候选的隧道，没有隧道两端连接着同一个交通枢纽。 现在有n家隧道施工的公司，每段候选的隧道只能由一个公司施工，每家公司施工需要的天数一致。而每家公司最多只能修建一条候选隧道。所有公司同时开始施工。 作为项目负责人，你获得了候选隧道的信息，现在你可以按自己的想法选择一部分隧道进行施工，请问修建整条地铁最少需要多少天。 输入格式输入的第一行包含两个整数n, m，用一个空格分隔，分别表示交通枢纽的数量和候选隧道的数量。 第2行到第m+1行，每行包含三个整数a, b, c，表示枢纽a和枢纽b之间可以修建一条隧道，需要的时间为c天。 输出格式输出一个整数，修建整条地铁线路最少需要的天数。 样例输入12345676 61 2 42 3 43 6 71 4 24 5 55 6 6 样例输出6 思路将所有边加入最小值优先队列，每次出队的即为剩下的边中最小的。每条边出队时，将这条边的两个顶点加入并查集的同一小组，判断 1 和 n 号枢纽是否连通。一旦连通，当前出队的这条边的权值即为所求答案。 PS，这道题考试的时候毫无思路。之后郑同学提出了一个思路，是这样的：求出当前所有非零边的权值中的最小值 minCost，然后给所有边的权值都减去这一 minCost，这时判断是否存在一条从起点到终点路径和为 0 的最短路。一旦存在，那么之前减去的所有 minCost 值之和就是答案。提交后发现答案错误只得了 5 分，应该是复杂度太高。然后发现，其实和上面 AC 的答案的思路的本质是一样的，都是不断找出所有的最短边，看是否能组成一条从起点到终点的路径。然鹅这两种思路都不是我想出来的Orz… 还需要一些想象力和变通能力（菜.jpg） 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;const int MAX_N = 100000 + 16;const int MAX_M = 200000 + 16;int n;int m;struct Edge &#123; int u, v, cost; Edge() &#123;&#125; Edge(int u, int v, int cost): u(u), v(v), cost(cost) &#123;&#125; bool operator&gt; (const Edge &amp;amp; e) const &#123; return cost &gt; e.cost; &#125;&#125;;Edge edge[MAX_M];int par[MAX_N];int rank[MAX_N];void init(int n) &#123; for (int i = 0; i &lt; n; i++) &#123; par[i] = i; rank[i] = 0; &#125;&#125;int find(int x) &#123; if (par[x] == x) &#123; return x; &#125; return find(par[x]);&#125;void unite(int x, int y) &#123; x = find(x); y = find(y); if (x == y) &#123; return; &#125; if (rank[x] &lt; rank[y]) &#123; par[x] = y; &#125; else &#123; par[y] = x; if (rank[x] == rank[y]) &#123; rank[x]++; &#125; &#125;&#125;bool same(int x, int y) &#123; return find(x) == find(y);&#125;int main() &#123; scanf(\"%d %d\", &amp;amp;n, &amp;amp;m); init(n + 1); int u, v, cost; priority_queue&lt;Edge, vector&lt;Edge&gt;, greater&lt;Edge&gt; &gt; que; for (int i = 0; i &lt; m; i++) &#123; scanf(\"%d %d %d\", &amp;amp;u, &amp;amp;v, &amp;amp;cost); que.push(Edge(u, v, cost)); &#125; int res = 0; while (!que.empty()) &#123; Edge e = que.top(); que.pop(); unite(e.u, e.v); if (same(1, n)) &#123; res = e.cost; break; &#125; &#125; cout &lt;&lt; res; return 0;","categories":[],"tags":[]},{"title":"POJ 2395 Out of Hay 题解 Kruskal 最小生成树","slug":"poj-2395-out-of-hay","date":"2017-04-04T12:05:52.000Z","updated":"2017-12-09T15:33:26.963Z","comments":true,"path":"2017/04/04/poj-2395-out-of-hay/","link":"","permalink":"//carolunar.com/2017/04/04/poj-2395-out-of-hay/","excerpt":"POJ 2395 Out of Hay 题意奶牛们的草要吃光了，这是非常可怕的事情。Bessie 决定走访每一家农场，看看她们的粮草情况。旅途艰难，Bessie 每走一公里就要喝一升水。给出连接 N 个农场的 M 条双向道路的长度，Bessie 想知道，自己走访完所有农场至少需要带一个多大的水壶。因为每到一个农场都可以灌满水壶，因此水壶容量只要够走最长的一条路就行。 思路求最小生成树的所有边中，权值最大的一条。","text":"POJ 2395 Out of Hay 题意奶牛们的草要吃光了，这是非常可怕的事情。Bessie 决定走访每一家农场，看看她们的粮草情况。旅途艰难，Bessie 每走一公里就要喝一升水。给出连接 N 个农场的 M 条双向道路的长度，Bessie 想知道，自己走访完所有农场至少需要带一个多大的水壶。因为每到一个农场都可以灌满水壶，因此水壶容量只要够走最长的一条路就行。 思路求最小生成树的所有边中，权值最大的一条。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define ONLINE_JUDGEusing namespace std;const int MAX_N = 2000 + 4;const int MAX_M = 10000 + 4;int N;int M;struct Edge &#123; int u, v, cost;&#125;;bool comp(Edge &amp;amp; e1, Edge &amp;amp; e2) &#123; return e1.cost &amp;lt; e2.cost;&#125;Edge edge[MAX_M];int par[MAX_N];int rank[MAX_N];void init(int n) &#123; for (int i = 0; i &amp;lt; n; i++) &#123; par[i] = i; rank[i] = 0; &#125;&#125;int find(int x) &#123; if (par[x] == x) &#123; return x; &#125; return par[x] = find(par[x]);&#125;void unite(int x, int y) &#123; x = find(x); y = find(y); if (x == y) &#123; return; &#125; if (rank[x] &amp;gt; rank[y]) &#123; par[y] = x; &#125; else &#123; par[x] = y; if (rank[x] == rank[y]) &#123; rank[y]++; &#125; &#125;&#125;bool same(int x, int y) &#123; return find(x) == find(y);&#125;int kruskal() &#123; init(N); int res = 0; sort(edge, edge + M, comp); for (int i = 0; i &amp;lt; M; i++) &#123; Edge e = edge[i]; if (!same(e.u, e.v)) &#123; unite(e.u, e.v); res = max(res, e.cost); &#125; &#125; return res;&#125;int main() &#123; #ifndef ONLINE_JUDGE freopen(\"in.txt\", \"r\", stdin); #endif scanf(\"%d %d\", &amp;amp;N, &amp;amp;M); int u, v; for (int i = 0; i &amp;lt; M; i++) &#123; scanf(\"%d %d %d\", &amp;amp;u, &amp;amp;v, &amp;amp;edge[i].cost); u--; v--; edge[i].u = u; edge[i].v = v; &#125; int res = kruskal(); printf(\"%d\", res); #ifndef ONLINE_JUDGE fclose(stdin); #endif return 0;&#125; &nbsp;","categories":[],"tags":[]},{"title":"AOJ 2224 Save your cats 题解 Kruskal 最小生成树","slug":"aoj-2224-save-your-cats","date":"2017-04-04T11:57:28.000Z","updated":"2017-12-09T15:33:26.936Z","comments":true,"path":"2017/04/04/aoj-2224-save-your-cats/","link":"","permalink":"//carolunar.com/2017/04/04/aoj-2224-save-your-cats/","excerpt":"AOJ 2224 Save your cats 题意救猫猫！花园里有很多可爱的小猫，邪恶的巫婆嫉妒这些小猫，就施魔法用篱笆把它们围起来了。主人要去救这些小猫，但是篱笆只有圣水才能破开，长度为 L 的篱笆需要数量为 L 的圣水。然而圣水又非常贵，给定每条篱笆的头尾的位置（都是坐标系中的格点），求最少花费多少圣水才能救出所有小猫。 思路建图略微有一点点的麻烦，给出每条边顶点的坐标，需要自己计算出权值。建好图之后，问题就转化成在去掉的边的权值最小的情况下把图变成树，所以就是一个求最大权生成树的问题。但是结果不是最大权和，而是去掉的边的和。依然转化成求最小生成树。","text":"AOJ 2224 Save your cats 题意救猫猫！花园里有很多可爱的小猫，邪恶的巫婆嫉妒这些小猫，就施魔法用篱笆把它们围起来了。主人要去救这些小猫，但是篱笆只有圣水才能破开，长度为 L 的篱笆需要数量为 L 的圣水。然而圣水又非常贵，给定每条篱笆的头尾的位置（都是坐标系中的格点），求最少花费多少圣水才能救出所有小猫。 思路建图略微有一点点的麻烦，给出每条边顶点的坐标，需要自己计算出权值。建好图之后，问题就转化成在去掉的边的权值最小的情况下把图变成树，所以就是一个求最大权生成树的问题。但是结果不是最大权和，而是去掉的边的和。依然转化成求最小生成树。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;math.h&gt;#include &lt;vector&gt;#define ONLINE_JUDGEusing namespace std;const int MAX_N = 10000 + 4;int N;int M;struct P &#123; int x, y; P() &#123;&#125; P(int x, int y): x(x), y(y) &#123;&#125;&#125;;struct Edge &#123; int u, v; double cost; Edge() &#123;&#125; Edge(int u, int v, double cost): u(u), v(v), cost(cost) &#123;&#125;&#125;;bool comp(Edge &amp;amp; e1, Edge &amp;amp; e2) &#123; return e1.cost &amp;lt; e2.cost;&#125;P pile[MAX_N];vector&lt;Edge&gt; edge;double sum;int par[MAX_N];int rank[MAX_N];void init(int n) &#123; for (int i = 0; i &amp;lt; n; i++) &#123; par[i] = i; rank[i] = 0; &#125;&#125;int find(int x) &#123; if (par[x] == x) &#123; return x; &#125; return par[x] = find(par[x]);&#125;void unite(int x, int y) &#123; x = find(x); y = find(y); if (x == y) &#123; return; &#125; if (rank[x] &amp;lt; rank[y]) &#123; par[x] = y; &#125; else &#123; par[y] = x; if (rank[x] == rank[y]) &#123; rank[x]++; &#125; &#125;&#125;bool same(int x, int y) &#123; return find(x) == find(y);&#125;void kruskal() &#123; init(N); sort(edge.begin(), edge.end(), comp); for (int i = 0; i &amp;lt; edge.size(); i++) &#123; Edge e = edge[i]; if (!same(e.u, e.v)) &#123; unite(e.u, e.v); sum -= e.cost; &#125; &#125;&#125;int main() &#123; #ifndef ONLINE_JUDGE freopen(\"in.txt\", \"r\", stdin); #endif scanf(\"%d %d\", &amp;amp;N, &amp;amp;M); int x, y; for (int i = 1; i &amp;lt;= N; i++) &#123; scanf(\"%d %d\", &amp;amp;pile[i].x, &amp;amp;pile[i].y); &#125; int u, v; double cost; sum = 0; for (int i = 0; i &amp;lt; M; i++) &#123; scanf(\"%d %d\", &amp;amp;u, &amp;amp;v); cost = -sqrt(pow((pile[u].x - pile[v].x), 2) + pow((pile[u].y - pile[v].y), 2)); sum += cost; edge.push_back(Edge(u, v, cost)); &#125; kruskal(); if (sum == 0.0) &#123; printf(\"0.000\"); &#125; else &#123; printf(\"%.3lf\", -sum); &#125; #ifndef ONLINE_JUDGE fclose(stdin); #endif return 0;&#125;","categories":[],"tags":[]},{"title":"POJ 2377 Bad Cowtractors 题解 Prim 最小生成树","slug":"poj-2377-bad-cowtractors","date":"2017-04-04T11:41:13.000Z","updated":"2017-12-09T15:33:26.976Z","comments":true,"path":"2017/04/04/poj-2377-bad-cowtractors/","link":"","permalink":"//carolunar.com/2017/04/04/poj-2377-bad-cowtractors/","excerpt":"题意FJ 雇 Bessie 帮他在不同的牛棚之间修建互联网，给定 M 条 连接 1 - N 号牛棚的线路及其费用，要求最终在两两互通的情况下花费最小。但他不打算给 Bessie 发工资，于是 Bessie 准备不好好干活，给他用最贵最贵的建设方法。 思路将所有道路的权重变成相反数，按照求最小生成树的算法，结果再取相反数就是最大生成树。 Prim 算法和求最短路的 Dijkrast 算法很相似。区别在于后者是从尚未使用过的顶点中选择一个距离源点最近的点，而 Prim 算法是从尚未使用过的点中选择 X（已使用的点集） 到其最近的点。 注意有可能本来就不连通，这时输出 -1。因此需要对输入用并查集检查连通性。每输入一条边就将其两个顶点放入并查集的一个小组内，最后一旦小组数超过 1，就说明是非连通图。","text":"题意FJ 雇 Bessie 帮他在不同的牛棚之间修建互联网，给定 M 条 连接 1 - N 号牛棚的线路及其费用，要求最终在两两互通的情况下花费最小。但他不打算给 Bessie 发工资，于是 Bessie 准备不好好干活，给他用最贵最贵的建设方法。 思路将所有道路的权重变成相反数，按照求最小生成树的算法，结果再取相反数就是最大生成树。 Prim 算法和求最短路的 Dijkrast 算法很相似。区别在于后者是从尚未使用过的顶点中选择一个距离源点最近的点，而 Prim 算法是从尚未使用过的点中选择 X（已使用的点集） 到其最近的点。 注意有可能本来就不连通，这时输出 -1。因此需要对输入用并查集检查连通性。每输入一条边就将其两个顶点放入并查集的一个小组内，最后一旦小组数超过 1，就说明是非连通图。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;queue&gt;#define ONLINE_JUDGEusing namespace std;const int MAX_N = 1000 + 4;const int INF = 0x3f3f3f3f;struct Edge &#123; int to; int cost; Edge() &#123;&#125; Edge(int to, int cost): to(to), cost(cost) &#123;&#125;&#125;;vector&lt;Edge&gt; G[MAX_N];int minCost[MAX_N];bool used[MAX_N];typedef pair&lt;int, int&gt; P;int N;int M;int par[MAX_N];int rank[MAX_N];void init(int n) &#123; for (int i = 0; i &amp;lt; n; i++) &#123; par[i] = i; rank[i] = 0; &#125;&#125;int find(int x) &#123; if (par[x] == x) &#123; return x; &#125; return find(par[x]);&#125;void unite(int x, int y) &#123; x = find(x); y = find(y); if (x == y) &#123; return; &#125; if (rank[x] &amp;lt; rank[y]) &#123; par[x] = y; &#125; else &#123; par[y] = x; if (rank[x] == rank[y]) &#123; rank[x]++; &#125; &#125;&#125;bool same(int x, int y) &#123; return find(x) == find(y);&#125;int prim() &#123; fill(minCost, minCost + N, INF); fill(used, used + N, false); minCost[0] = 0; priority_queue&lt;P, vector&amp;lt;P&amp;gt;, greater&amp;lt;P&amp;gt; &gt; que; que.push(P(0, 0)); int res = 0; while (!que.empty()) &#123; P p = que.top(); que.pop(); int v = p.second; if (minCost[v] &amp;lt; p.first) &#123; continue; &#125; used[v] = true; res += p.first; for (int i = 0; i &amp;lt; G[v].size(); i++) &#123; Edge e = G[v][i]; if (!used[e.to] &amp;amp;&amp;amp; minCost[e.to] &amp;gt; e.cost) &#123; minCost[e.to] = e.cost; que.push(P(minCost[e.to], e.to)); &#125; &#125; &#125; return res;&#125;int main() &#123; #ifndef ONLINE_JUDGE freopen(\"in.txt\", \"r\", stdin); #endif scanf(\"%d %d\", &amp;amp;N, &amp;amp;M); init(N); int from, to, cost; for (int i = 0; i &amp;lt; M; i++) &#123; scanf(\"%d %d %d\", &amp;amp;from, &amp;amp;to, &amp;amp;cost); from--; to--; unite(from, to); G[from].push_back(Edge(to, -cost)); G[to].push_back(Edge(from, -cost)); &#125; int res = -1; bool connected = true; for (int i = 1; i &amp;lt; N; i++) &#123; if (!same(0, i)) &#123; connected = false; break; &#125; &#125; if (connected) &#123; res = -prim(); &#125; cout &amp;lt;&amp;lt; res; #ifndef ONLINE_JUDGE fclose(stdin); #endif return 0;&#125; &nbsp; &nbsp;","categories":[],"tags":[]},{"title":"POJ 1258 Agri-Net 题解 Prim 最小生成树","slug":"poj-1258-agri-net","date":"2017-04-04T11:25:11.000Z","updated":"2017-12-09T15:33:26.967Z","comments":true,"path":"2017/04/04/poj-1258-agri-net/","link":"","permalink":"//carolunar.com/2017/04/04/poj-1258-agri-net/","excerpt":"POJ 1258 Agri-Net 题意FJ 当市长了，他的政治宣言之一就是让所有奶牛都用上互联网。求出连接所有农场的最小花费。 思路求最小生成树，用 Prim 算法。","text":"POJ 1258 Agri-Net 题意FJ 当市长了，他的政治宣言之一就是让所有奶牛都用上互联网。求出连接所有农场的最小花费。 思路求最小生成树，用 Prim 算法。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define ONLINE_JUDGEusing namespace std;const int MAX_N = 100 + 4;const int INF = 0x3f3f3f3f;struct Edge &#123; int to; int cost; Edge() &#123;&#125; Edge(int to, int cost): to(to), cost(cost) &#123;&#125;&#125;; vector&lt;Edge&gt; G[MAX_N];int minCost[MAX_N];bool used[MAX_N];typedef pair&lt;int, int&gt; P;int N;int prim() &#123; fill(minCost, minCost + N, INF); fill(used, used + N, false); minCost[0] = 0; priority_queue&lt;P, vector&amp;lt;P&amp;gt;, greater&amp;lt;P&amp;gt; &gt; que; que.push(P(0, 0)); int res = 0; while (!que.empty()) &#123; P p = que.top(); que.pop(); int v = p.second; if (minCost[v] &amp;lt; p.first) &#123; continue; &#125; used[v] = true; res += p.first; for (int i = 0; i &amp;lt; G[v].size(); i++) &#123; Edge e = G[v][i]; if (!used[e.to] &amp;amp;&amp;amp; minCost[e.to] &amp;gt; e.cost) &#123; minCost[e.to] = e.cost; que.push(P(minCost[e.to], e.to)); &#125; &#125; &#125; return res;&#125;int main() &#123; #ifndef ONLINE_JUDGE freopen(\"in.txt\", \"r\", stdin); #endif while (1) &#123; if (scanf(\"%d\", &amp;amp;N) == EOF) &#123; break; &#125; int cost; for (int i = 0; i &amp;lt; N; i++) &#123; G[i].clear(); for (int j = 0; j &amp;lt; N; j++) &#123; scanf(\"%d\", &amp;amp;cost); if (i != j) &#123; G[i].push_back(Edge(j, cost)); &#125; &#125; &#125; int res = prim(); printf(\"%d\\n\", res); &#125; #ifndef ONLINE_JUDGE fclose(stdin); #endif return 0;&#125; 8573524 carolunar POJ 1258 Accepted 16 0.3 1671 C++ 2017-03-27 16:00:57&nbsp;","categories":[],"tags":[]},{"title":"AOJ 2249 Road Construction 题解 Dijkstra 最短路","slug":"aoj-2249-road-construction","date":"2017-04-04T08:50:16.000Z","updated":"2017-12-09T15:33:26.954Z","comments":true,"path":"2017/04/04/aoj-2249-road-construction/","link":"","permalink":"//carolunar.com/2017/04/04/aoj-2249-road-construction/","excerpt":"AOJ 2249 Road Construction 题意ACM 王国要修路。现有一个修路方案，此方案给出了连接王国的首都和其他城市的一些路线的距离和费用，可以确保任意两个城市之间是连通的。现在为了降低预算，需要修改这个方案。要求修改后的方案依然保持任意两点的连通性并且，首都到其他每个城市的最短距离不要变，在这两个前提下，求出修改后的方案的最低预算。 思路这是一个单源最短路问题。可以看成在给定的一个地图上，要求出首都到其他各个城市的最短路的建设费用之和。 求最短路倒是简单，但是这个最少费用怎么求有点麻烦。看了别人的代码，思路是，在求出单源最短路之后，遍历除首都外的每个点 i，看下这条最短路是经过 i 的哪一个邻居结点来到 i 的，假设为 t，那么费用就在原来的基础上加上 i 与 t 之间的建设费用。这样在遍历所有结点的同时，也遍历了所有结点的最短路，同时不会出现同一条边的费用被计算两次的情况。假设边 e(i, j) 是首都到结点 j 的最短路上的最后一段，那么在遍历到 j 的时候就会加上这一条边的费用。而遍历到 i 的时候，首都到 i 的最短路必然不会经过边 e(i, j)，也就不会被重复计算。在这个过程中，每个结点只关心与自己相连的那条路的费用，等全部遍历完成的时候，自然就得出了整体的最少费用。","text":"AOJ 2249 Road Construction 题意ACM 王国要修路。现有一个修路方案，此方案给出了连接王国的首都和其他城市的一些路线的距离和费用，可以确保任意两个城市之间是连通的。现在为了降低预算，需要修改这个方案。要求修改后的方案依然保持任意两点的连通性并且，首都到其他每个城市的最短距离不要变，在这两个前提下，求出修改后的方案的最低预算。 思路这是一个单源最短路问题。可以看成在给定的一个地图上，要求出首都到其他各个城市的最短路的建设费用之和。 求最短路倒是简单，但是这个最少费用怎么求有点麻烦。看了别人的代码，思路是，在求出单源最短路之后，遍历除首都外的每个点 i，看下这条最短路是经过 i 的哪一个邻居结点来到 i 的，假设为 t，那么费用就在原来的基础上加上 i 与 t 之间的建设费用。这样在遍历所有结点的同时，也遍历了所有结点的最短路，同时不会出现同一条边的费用被计算两次的情况。假设边 e(i, j) 是首都到结点 j 的最短路上的最后一段，那么在遍历到 j 的时候就会加上这一条边的费用。而遍历到 i 的时候，首都到 i 的最短路必然不会经过边 e(i, j)，也就不会被重复计算。在这个过程中，每个结点只关心与自己相连的那条路的费用，等全部遍历完成的时候，自然就得出了整体的最少费用。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;memory.h&gt;#define ONLINE_JUDGEusing namespace std;const int INF = 0x3f3f3f3f;const int MAX_N = 10000 + 4;struct Edge &#123; int to; int cost; int distance; Edge() &#123;&#125; Edge(int to, int cost, int distance): to(to), cost(cost), distance(distance) &#123;&#125;&#125;;typedef pair&lt;int, int&gt; P;vector&lt;Edge&gt; G[MAX_N];int d[MAX_N];int N;int M;void dijkrast(int s) &#123; priority_queue&lt;P, vector&amp;lt;P&amp;gt;, greater&amp;lt;P&amp;gt; &gt; que; fill(d, d + MAX_N, INF); d[s] = 0; que.push(P(0, s)); while (!que.empty()) &#123; P p = que.top(); que.pop(); int v = p.second; if (d[v] &amp;lt; p.first) &#123; continue; &#125; for (int i = 0; i &amp;lt; G[v].size(); i++) &#123; Edge e = G[v][i]; if (d[e.to] &amp;gt; d[v] + e.distance) &#123; d[e.to] = d[v] + e.distance; que.push(P(d[e.to], e.to)); &#125; &#125; &#125; &#125;int main() &#123; #ifndef ONLINE_JUDGE freopen(\"in.txt\", \"r\", stdin); #endif while (scanf(\"%d %d\", &amp;amp;N, &amp;amp;M) &amp;amp;&amp;amp; N) &#123; for (int i = 0; i &amp;lt; MAX_N; i++) &#123; G[i].clear(); &#125; int u, v, distance, cost; for (int i = 0; i &amp;lt; M; i++) &#123; scanf(\"%d %d %d %d\", &amp;amp;u, &amp;amp;v, &amp;amp;distance, &amp;amp;cost); G[u].push_back(Edge(v, cost, distance)); G[v].push_back(Edge(u, cost, distance)); &#125; dijkrast(1); int res = 0; for (int i = 2; i &amp;lt;= N; i++) &#123; int minCost = INF; for (int j = 0; j &amp;lt; G[i].size(); j++) &#123; if (d[i] == d[G[i][j].to] + G[i][j].distance) &#123; minCost = min(minCost, G[i][j].cost); &#125; &#125; res += minCost; &#125; printf(\"%d\\n\", res); &#125; #ifndef ONLINE_JUDGE fclose(stdin); #endif return 0;&#125; &nbsp; 8550024carolunarAizu2249Accepted505.11916C++2017-03-25 11:54:23 参考码农场 » AOJ 2249 Road Construction 题解 《挑战程序设计竞赛》 &nbsp;","categories":[],"tags":[]},{"title":"POJ 3268 Silver Cow Party 题解 dijkstra 最短路","slug":"poj-3268-silver-cow-party","date":"2017-04-04T03:31:29.000Z","updated":"2017-12-09T15:33:26.978Z","comments":true,"path":"2017/04/04/poj-3268-silver-cow-party/","link":"","permalink":"//carolunar.com/2017/04/04/poj-3268-silver-cow-party/","excerpt":"POJ 3268 Silver Cow Party 题意N 个农场之间有 M 条单向道路相连，现在每个农场的奶牛都要去 X 号农场参加 party，如果所有奶牛都机智地选择最短路走的话，那么路程最长的奶牛走过的路有多长。 思路有向图的多源最短路径问题。一开始一直 TLE，参考了别人的题解。存疑。","text":"POJ 3268 Silver Cow Party 题意N 个农场之间有 M 条单向道路相连，现在每个农场的奶牛都要去 X 号农场参加 party，如果所有奶牛都机智地选择最短路走的话，那么路程最长的奶牛走过的路有多长。 思路有向图的多源最短路径问题。一开始一直 TLE，参考了别人的题解。存疑。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define ONLINE_JUDGEusing namespace std;const int MAX_N = 1000 + 4;const int INF = 0x3f3f3f3f;int N, M, X;int d[MAX_N][MAX_N]; struct Edge &#123; int to; int cost; Edge () &#123;&#125; Edge (int to, int cost) &#123; this-&amp;gt;to = to; this-&amp;gt;cost = cost; &#125;&#125;;vector&lt;Edge&gt; G[MAX_N];typedef pair&lt;int, int&gt; P;void dijkstra(int s) &#123; fill(d[s], d[s] + MAX_N, INF); d[s][s] = 0; priority_queue&lt;P, vector&amp;lt;P&amp;gt;, greater&amp;lt;P&amp;gt; &gt; que; que.push(P(0, s)); while (que.size()) &#123; P p = que.top(); que.pop(); int v = p.second; if (p.first &amp;gt; d[s][v]) &#123; continue; &#125; for (int i = 0; i &amp;lt; G[v].size(); i++) &#123; Edge e = G[v][i]; if (p.first + e.cost &amp;lt; d[s][e.to]) &#123; d[s][e.to] = p.first + e.cost; que.push(P(d[s][e.to], e.to)); &#125; &#125; &#125;&#125;int main() &#123; #ifndef ONLINE_JUDGE freopen(\"in.txt\", \"r\", stdin); #endif scanf(\"%d %d %d\", &amp;amp;N, &amp;amp;M, &amp;amp;X); int from, to, cost; for (int i = 0; i &amp;lt; M; i++) &#123; scanf(\"%d %d %d\", &amp;amp;from, &amp;amp;to, &amp;amp;cost); G[from].push_back(Edge(to, cost)); &#125; int total[MAX_N]; for (int i = 1; i &amp;lt;= N; i++) &#123; dijkstra(i); &#125; for (int i = 1; i &amp;lt;= N; i++) &#123; total[i] = d[i][X] + d[X][i]; &#125; printf(\"%d\", *max_element(total + 1, total + N + 1)); #ifndef ONLINE_JUDGE fclose(stdin); #endif return 0;&#125; &nbsp;","categories":[],"tags":[]},{"title":"POJ 3259 Wormholes 题解 Bellman-Ford 负圈","slug":"poj-3259-wormholes","date":"2017-04-04T03:22:45.000Z","updated":"2017-12-09T15:33:26.958Z","comments":true,"path":"2017/04/04/poj-3259-wormholes/","link":"","permalink":"//carolunar.com/2017/04/04/poj-3259-wormholes/","excerpt":"POJ 3259 Wormholes 题意FJ 有 N 块田地，由 M 条双向道路相连，神奇的是还有 W 个单向的虫洞相连。虫洞是什么呢，就是你经过这个洞之后就会回到过去。求 FJ 是否有可能在某个圈中绕一圈后回到过去。 思路图中有正权无向边和负权有向边，其实就是求是否存在负圈。建好图之后，用 BellmanFord 算法可以检查出负圈的存在。","text":"POJ 3259 Wormholes 题意FJ 有 N 块田地，由 M 条双向道路相连，神奇的是还有 W 个单向的虫洞相连。虫洞是什么呢，就是你经过这个洞之后就会回到过去。求 FJ 是否有可能在某个圈中绕一圈后回到过去。 思路图中有正权无向边和负权有向边，其实就是求是否存在负圈。建好图之后，用 BellmanFord 算法可以检查出负圈的存在。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;memory.h&gt;#define ONLINE_JUDGEusing namespace std;const int MAX_N = 500 + 4;const int INF = 0x3f3f3f3f;struct Edge &#123; int from; int to; int cost; Edge() &#123;&#125; Edge(int from, int to, int cost) &#123; this-&amp;gt;from = from; this-&amp;gt;to = to; this-&amp;gt;cost = cost; &#125;&#125;;vector&lt;Edge&gt; edge;int cost[MAX_N][MAX_N];int d[MAX_N];int F;int N;int M;int W;bool BellmanFord () &#123; memset(d, 0, sizeof(d)); for (int v = 0; v &amp;lt; N; v++) &#123; for (int i = 0; i &amp;lt; edge.size(); i++) &#123; Edge e = edge[i]; if (d[e.to] &amp;gt; d[e.from] + e.cost) &#123; d[e.to] = d[e.from] + e.cost; if (v == N - 1) &#123; return true; &#125; &#125; &#125; &#125; return false;&#125;int main() &#123; #ifndef ONLINE_JUDGE freopen(\"in.txt\", \"r\", stdin); #endif scanf(\"%d\", &amp;amp;F); while (F--) &#123; edge.clear(); scanf(\"%d %d %d\", &amp;amp;N, &amp;amp;M, &amp;amp;W); int from, to, cost; for (int i = 0; i &amp;lt; M; i++) &#123; scanf(\"%d %d %d\", &amp;amp;from, &amp;amp;to, &amp;amp;cost); Edge e1(from, to, cost); Edge e2(to, from, cost); edge.push_back(e1); edge.push_back(e2); &#125; for (int i = 0; i &amp;lt; W; i++) &#123; scanf(\"%d %d %d\", &amp;amp;from, &amp;amp;to, &amp;amp;cost); Edge e(from, to, -cost); edge.push_back(e); &#125; bool res = BellmanFord(); if (res) &#123; printf(\"YES\\n\"); &#125; else &#123; printf(\"NO\\n\"); &#125; &#125; #ifndef ONLINE_JUDGE fclose(stdin); #endif return 0;&#125;","categories":[],"tags":[]},{"title":"POJ 3461 Oulipo 题解 KMP","slug":"poj-3461-oulipo","date":"2017-04-03T13:23:16.000Z","updated":"2017-12-09T15:33:26.930Z","comments":true,"path":"2017/04/03/poj-3461-oulipo/","link":"","permalink":"//carolunar.com/2017/04/03/poj-3461-oulipo/","excerpt":"题意给定两个字符串 W 和 T，求 W 在 T 中出现的次数。 思路KMP 算法的应用题。 看了一天可算是看明白了。 感想：感性层面理解一个算法和落实到代码上，还差了 10 页《算法导论》吧。毕竟传说中，数据结构老师上小学的女儿都可以帮她批阅期末考试的卷子… 引用一篇别人的博客（阮一峰），便于温习感性认识。至于实现细节，需要看某导论和代码。 字符串匹配是计算机的基本任务之一。 举例来说，有一个字符串”BBC ABCDAB ABCDABCDABDE”，我想知道，里面是否包含另一个字符串”ABCDABD”？ 许多算法可以完成这个任务，Knuth-Morris-Pratt算法（简称KMP）是最常用的之一。它以三个发明者命名，起头的那个K就是著名科学家Donald Knuth。 这种算法不太容易理解，网上有很多解释，但读起来都很费劲。直到读到Jake Boxer的文章，我才真正理解这种算法。下面，我用自己的语言，试图写一篇比较好懂的KMP算法解释。 1. 首先，字符串”BBC ABCDAB ABCDABCDABDE”的第一个字符与搜索词”ABCDABD”的第一个字符，进行比较。因为B与A不匹配，所以搜索词后移一位。 2. 因为B与A不匹配，搜索词再往后移。 3. 就这样，直到字符串有一个字符，与搜索词的第一个字符相同为止。 4. 接着比较字符串和搜索词的下一个字符，还是相同。 5. 直到字符串有一个字符，与搜索词对应的字符不相同为止。 6. 这时，最自然的反应是，将搜索词整个后移一位，再从头逐个比较。这样做虽然可行，但是效率很差，因为你要把”搜索位置”移到已经比较过的位置，重比一遍。 7. 一个基本事实是，当空格与D不匹配时，你其实知道前面六个字符是”ABCDAB”。KMP算法的想法是，设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这样就提高了效率。 8. 怎么做到这一点呢？可以针对搜索词，算出一张《部分匹配表》（Partial Match Table）。这张表是如何产生的，后面再介绍，这里只要会用就可以了。 9. 已知空格与D不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符B对应的”部分匹配值”为2，因此按照下面的公式算出向后移动的位数： 移动位数 = 已匹配的字符数 - 对应的部分匹配值 因为 6 - 2 等于4，所以将搜索词向后移动4位。 10. 因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（”AB”），对应的”部分匹配值”为0。所以，移动位数 = 2 - 0，结果为 2，于是将搜索词向后移2位。 11. 因为空格与A不匹配，继续后移一位。 12. 逐位比较，直到发现C与D不匹配。于是，移动位数 = 6 - 2，继续将搜索词向后移动4位。 13. 逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数 = 7 - 0，再将搜索词向后移动7位，这里就不再重复了。 14. 下面介绍《部分匹配表》是如何产生的。 首先，要了解两个概念：”前缀”和”后缀”。 “前缀”指除了最后一个字符以外，一个字符串的全部头部组合；”后缀”指除了第一个字符以外，一个字符串的全部尾部组合。 15. “部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度。以”ABCDABD”为例， － “A”的前缀和后缀都为空集，共有元素的长度为0； － “AB”的前缀为[A]，后缀为[B]，共有元素的长度为0； － “ABC”的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0； － “ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0； － “ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为1； － “ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”，长度为2； － “ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。 16. “部分匹配”的实质是，有时候，字符串头部和尾部会有重复。比如，”ABCDAB”之中有两个”AB”，那么它的”部分匹配值”就是2（”AB”的长度）。搜索词移动的时候，第一个”AB”向后移动4位（字符串长度-部分匹配值），就可以来到第二个”AB”的位置。 * 另外，《算法导论》 32.4节，590页有一处错误，第一段示例代码 12 行的 q = Pi(q) 需要再向右缩进一层。 * 再另外，我的体会是，不要去想那么多“模式串右移几位”的事，直接看做是比较两个串的第几位和第几位，更直观和容易理解一点，又不是非得对齐了才能比较。我觉得斜着瞅一眼要比想着怎么移动省事一些。","text":"题意给定两个字符串 W 和 T，求 W 在 T 中出现的次数。 思路KMP 算法的应用题。 看了一天可算是看明白了。 感想：感性层面理解一个算法和落实到代码上，还差了 10 页《算法导论》吧。毕竟传说中，数据结构老师上小学的女儿都可以帮她批阅期末考试的卷子… 引用一篇别人的博客（阮一峰），便于温习感性认识。至于实现细节，需要看某导论和代码。 字符串匹配是计算机的基本任务之一。 举例来说，有一个字符串”BBC ABCDAB ABCDABCDABDE”，我想知道，里面是否包含另一个字符串”ABCDABD”？ 许多算法可以完成这个任务，Knuth-Morris-Pratt算法（简称KMP）是最常用的之一。它以三个发明者命名，起头的那个K就是著名科学家Donald Knuth。 这种算法不太容易理解，网上有很多解释，但读起来都很费劲。直到读到Jake Boxer的文章，我才真正理解这种算法。下面，我用自己的语言，试图写一篇比较好懂的KMP算法解释。 1. 首先，字符串”BBC ABCDAB ABCDABCDABDE”的第一个字符与搜索词”ABCDABD”的第一个字符，进行比较。因为B与A不匹配，所以搜索词后移一位。 2. 因为B与A不匹配，搜索词再往后移。 3. 就这样，直到字符串有一个字符，与搜索词的第一个字符相同为止。 4. 接着比较字符串和搜索词的下一个字符，还是相同。 5. 直到字符串有一个字符，与搜索词对应的字符不相同为止。 6. 这时，最自然的反应是，将搜索词整个后移一位，再从头逐个比较。这样做虽然可行，但是效率很差，因为你要把”搜索位置”移到已经比较过的位置，重比一遍。 7. 一个基本事实是，当空格与D不匹配时，你其实知道前面六个字符是”ABCDAB”。KMP算法的想法是，设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这样就提高了效率。 8. 怎么做到这一点呢？可以针对搜索词，算出一张《部分匹配表》（Partial Match Table）。这张表是如何产生的，后面再介绍，这里只要会用就可以了。 9. 已知空格与D不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符B对应的”部分匹配值”为2，因此按照下面的公式算出向后移动的位数： 移动位数 = 已匹配的字符数 - 对应的部分匹配值 因为 6 - 2 等于4，所以将搜索词向后移动4位。 10. 因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（”AB”），对应的”部分匹配值”为0。所以，移动位数 = 2 - 0，结果为 2，于是将搜索词向后移2位。 11. 因为空格与A不匹配，继续后移一位。 12. 逐位比较，直到发现C与D不匹配。于是，移动位数 = 6 - 2，继续将搜索词向后移动4位。 13. 逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数 = 7 - 0，再将搜索词向后移动7位，这里就不再重复了。 14. 下面介绍《部分匹配表》是如何产生的。 首先，要了解两个概念：”前缀”和”后缀”。 “前缀”指除了最后一个字符以外，一个字符串的全部头部组合；”后缀”指除了第一个字符以外，一个字符串的全部尾部组合。 15. “部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度。以”ABCDABD”为例， － “A”的前缀和后缀都为空集，共有元素的长度为0； － “AB”的前缀为[A]，后缀为[B]，共有元素的长度为0； － “ABC”的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0； － “ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0； － “ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为1； － “ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”，长度为2； － “ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。 16. “部分匹配”的实质是，有时候，字符串头部和尾部会有重复。比如，”ABCDAB”之中有两个”AB”，那么它的”部分匹配值”就是2（”AB”的长度）。搜索词移动的时候，第一个”AB”向后移动4位（字符串长度-部分匹配值），就可以来到第二个”AB”的位置。 * 另外，《算法导论》 32.4节，590页有一处错误，第一段示例代码 12 行的 q = Pi(q) 需要再向右缩进一层。 * 再另外，我的体会是，不要去想那么多“模式串右移几位”的事，直接看做是比较两个串的第几位和第几位，更直观和容易理解一点，又不是非得对齐了才能比较。我觉得斜着瞅一眼要比想着怎么移动省事一些。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;memory.h&gt;using namespace std;const int MAX_N = 1000000 + 16;char W[MAX_N];char T[MAX_N];int Pi[MAX_N];void computePrefix(char * P) &#123; memset(Pi, 0, sizeof(Pi)); int n = strlen(P); int k = 0; Pi[0] = 0; for (int q = 1; q &amp;lt; n; q++) &#123; while (k &amp;gt; 0 &amp;amp;&amp;amp; P[q] != P[k]) &#123; k = Pi[k - 1]; &#125; if (P[q] == P[k]) &#123; k++; &#125; Pi[q] = k; &#125;&#125;int KMP(char * T, char * P) &#123; int res = 0; int n = strlen(T); int m = strlen(P); int q = 0; //numbers of characters matched computePrefix(P); for (int i = 0; i &amp;lt; n; i++) &#123; while (q &amp;gt; 0 &amp;amp;&amp;amp; P[q] != T[i]) &#123; q = Pi[q - 1]; &#125; if (P[q] == T[i]) &#123; q++; &#125; if (q == m) &#123; res++; q = Pi[q - 1]; &#125; &#125; return res;&#125;int main() &#123; int C; scanf(\"%d\", &amp;amp;C); while (C--) &#123; scanf(\"%s\", W); scanf(\"%s\", T); printf(\"%d\\n\", KMP(T, W)); &#125; return 0;&#125; 8650221carolunarPOJ3461Accepted1575.11182C++2017-04-03 20:14:50","categories":[],"tags":[]},{"title":"HDU 3068 最长回文 题解 Manacher","slug":"hdu-3068-longest-palindrome","date":"2017-04-03T13:06:55.000Z","updated":"2017-12-09T15:33:26.949Z","comments":true,"path":"2017/04/03/hdu-3068-longest-palindrome/","link":"","permalink":"//carolunar.com/2017/04/03/hdu-3068-longest-palindrome/","excerpt":"题意给定一个字符串，求该字符串中出现的最长的回文串的长度。 思路Manacher 算法的应用题。 Manacher 算法先将给定的字符串进行预处理，在其首尾以及每两个字符的间隔处插入一个字符（如’$’, 必须是该字符串中一定不会出现的），如 abc -&gt; $a$b$c$, abcd -&gt; $a$b$c$d$。使得无论是奇数长度还是偶数长度的串，都变成奇数长度，这样避免了分情况处理。 令 p[i] 表示以第 i 个字符为中心的最长的回文串的半径，最终 p[1..n] 中的最大值即为答案。 这个算法很好理解，关键在求 p[i] 的时候巧妙利用了以前得到的信息，降低了复杂度。 令 id 表示当前求出半径的所有回文串里面，向右延伸最远的那个串的中心下标。注意不是半径最长，而是（本身的位置 + 半径）最长。举个例子，一条线段上从左到右每个格点都站了一个人，每个人的胳膊可能不一样长。id 就表示是胳膊向右可以够到最远的那个人的位置，而非胳膊最长的人。 接下来，求点 i 的回文半径的时候，如果 i 处于这个 p[id] + id 之内，i 关于 id 的对称点 id - (i - id) -&gt; 2id - i 也在 id 的左边的半径内。 令 P 表示这个对称点，那么有两种情况： P 的回文半径小于 p[id]，此时 p[i] 一定等于 p[2id - 1]。 P 的回文半径大于或等于 p[id], 此时令 p[i] 暂且等于这个半径处于 p[id] 内的这一段，再向两边穷举直到不匹配。","text":"题意给定一个字符串，求该字符串中出现的最长的回文串的长度。 思路Manacher 算法的应用题。 Manacher 算法先将给定的字符串进行预处理，在其首尾以及每两个字符的间隔处插入一个字符（如’$’, 必须是该字符串中一定不会出现的），如 abc -&gt; $a$b$c$, abcd -&gt; $a$b$c$d$。使得无论是奇数长度还是偶数长度的串，都变成奇数长度，这样避免了分情况处理。 令 p[i] 表示以第 i 个字符为中心的最长的回文串的半径，最终 p[1..n] 中的最大值即为答案。 这个算法很好理解，关键在求 p[i] 的时候巧妙利用了以前得到的信息，降低了复杂度。 令 id 表示当前求出半径的所有回文串里面，向右延伸最远的那个串的中心下标。注意不是半径最长，而是（本身的位置 + 半径）最长。举个例子，一条线段上从左到右每个格点都站了一个人，每个人的胳膊可能不一样长。id 就表示是胳膊向右可以够到最远的那个人的位置，而非胳膊最长的人。 接下来，求点 i 的回文半径的时候，如果 i 处于这个 p[id] + id 之内，i 关于 id 的对称点 id - (i - id) -&gt; 2id - i 也在 id 的左边的半径内。 令 P 表示这个对称点，那么有两种情况： P 的回文半径小于 p[id]，此时 p[i] 一定等于 p[2id - 1]。 P 的回文半径大于或等于 p[id], 此时令 p[i] 暂且等于这个半径处于 p[id] 内的这一段，再向两边穷举直到不匹配。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;using namespace std;const int MAX_N = 110000 + 16;int p[MAX_N * 2];char s[MAX_N * 2];int main() &#123; while (scanf(\"%s\", s) != EOF) &#123; int len = strlen(s); for (int i = len; i &amp;gt;= 0; i--) &#123; s[i + i + 2] = s[i]; s[i + i + 1] = '#'; &#125; s[0] = '$'; int id = 0; int maxLen = 0; for (int i = 2; i &amp;lt; 2 * len + 1; i++) &#123; if (i &amp;lt; id + p[id]) &#123; p[i] = min(p[id] + id - i, p[2 * id - i]); &#125; else &#123; p[i] = 1; &#125; while (s[i - p[i]] == s[i + p[i]]) &#123; p[i]++; &#125; if (id + p[id] &amp;lt; i + p[i]) &#123; id = i; &#125; if (maxLen &amp;lt; p[i]) &#123; maxLen = p[i]; &#125; &#125; cout &amp;lt;&amp;lt; maxLen - 1 &amp;lt;&amp;lt; endl; &#125; return 0;&#125; 8644040carolunarHDU3068Accepted4362.81000C++2017-04-03 11:55:31","categories":[],"tags":[]},{"title":"POJ 1159 Palindrome 题解","slug":"poj-1159-palindrome","date":"2017-04-03T03:02:40.000Z","updated":"2017-12-09T15:33:26.965Z","comments":true,"path":"2017/04/03/poj-1159-palindrome/","link":"","permalink":"//carolunar.com/2017/04/03/poj-1159-palindrome/","excerpt":"POJ 1159 Palindrome 题意给定一个长度为 N 的字符串 S，求最少添加几个字符可以让该串变成回文串。 思路令 S’ 为 S 的逆序串，求出 S 和 S’ 的最长公共子串的长度 L, 则 N - L 即为结果。 注意直接用 DP 的话，需要 N N 的数组，会 MLE, 因此压缩成 2 N 的数组。","text":"POJ 1159 Palindrome 题意给定一个长度为 N 的字符串 S，求最少添加几个字符可以让该串变成回文串。 思路令 S’ 为 S 的逆序串，求出 S 和 S’ 的最长公共子串的长度 L, 则 N - L 即为结果。 注意直接用 DP 的话，需要 N N 的数组，会 MLE, 因此压缩成 2 N 的数组。 代码12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;memory.h&gt;#include &lt;algorithm&gt;using namespace std;const int MAX_N = 5000;int N;char str[MAX_N + 4];char rts[MAX_N + 4];int dp[2][MAX_N + 4];int main() &#123; cin &amp;gt;&amp;gt; N; cin.ignore(); for (int i = 1; i &amp;lt;= N; i++) &#123; scanf(\"%c\", &amp;amp;str[i]); rts[N + 1 - i] = str[i]; &#125; for (int i = 1; i &amp;lt;= N; i++) &#123; int cur = i &amp;amp; 0x1; int pre = (i - 1) &amp;amp; 0x1; memset(dp[cur], 0, sizeof(dp[cur])); for (int j = 1; j &amp;lt;= N; j++) &#123; if (str[i] == rts[j]) &#123; dp[cur][j] = dp[pre][j - 1] + 1; &#125; else &#123; dp[cur][j] = max(dp[pre][j], dp[cur][j - 1]); &#125; &#125; &#125; cout &amp;lt;&amp;lt; N - dp[N &amp;amp; 0x1][N]; return 0;&#125; &nbsp;","categories":[],"tags":[]},{"title":"蓝桥杯 ALGO-137 Lift and Throw 题解","slug":"lanqiao-algo-137-lift-and-throw","date":"2017-04-02T06:37:15.000Z","updated":"2017-12-09T15:33:26.946Z","comments":true,"path":"2017/04/02/lanqiao-algo-137-lift-and-throw/","link":"","permalink":"//carolunar.com/2017/04/02/lanqiao-algo-137-lift-and-throw/","excerpt":"题目 问题描述 给定一条标有整点(1, 2, 3, …)的射线. 定义两个点之间的距离为其下标之差的绝对值. Laharl, Etna, Flonne一开始在这条射线上不同的三个点, 他们希望其中某个人能够到达下标最大的点. 每个角色只能进行下面的3种操作, 且每种操作不能每人不能进行超过一次. 1.移动一定的距离 2.把另一个角色高举过头 3.将举在头上的角色扔出一段距离 每个角色有一个movement range参数, 他们只能移动到没有人的位置, 并且起点和终点的距离不超过movement range. 如果角色A和另一个角色B距离为1, 并且角色B没有被别的角色举起, 那么A就能举起B. 同时, B会移动到A的位置,B原来所占的位置变为没有人的位置. 被举起的角色不能进行任何操作, 举起别人的角色不能移动.同时, 每个角色还有一个throwing range参数, 即他能把举起的角色扔出的最远的距离. 注意, 一个角色只能被扔到没有别的角色占据的位置. 我们认为一个角色举起另一个同样举起一个角色的角色是允许的. 这种情况下会出现3个人在同一个位置的情况. 根据前面的描述, 这种情况下上面的两个角色不能进行任何操作, 而最下面的角色可以同时扔出上面的两个角色. 你的任务是计算这些角色能够到达的位置的最大下标, 即最大的数字x, 使得存在一个角色能够到达x. 输入格式 输入共三行, 分别为Laharl, Etna, Floone的信息. 每一行有且仅有3个整数, 描述对应角色的初始位置, movement range, throwing range. 数据保证3个角色的初始位置两两不相同且所有的数字都在1到10之间. 输出格式 仅有1个整数, 即Laharl, Etna, Flonne之一能到达的最大距离. 样例输入 9 3 3 4 3 1 2 3 3 样例输出 15 样例说明 一开始Laharl在位置9, Etna在位置4, Flonne在位置2. 首先, Laharl移动到6. 然后Flonne移动到位置5并且举起Etna. Laharl举起Flonne将其扔到位置9. Flonne把Etna扔到位置12. Etna移动到位置15. 思路 这道题跟之前做过的 Curling 2.0 是同样的思路，用 DFS + 回溯去遍历所有可能的状态。","text":"题目 问题描述 给定一条标有整点(1, 2, 3, …)的射线. 定义两个点之间的距离为其下标之差的绝对值. Laharl, Etna, Flonne一开始在这条射线上不同的三个点, 他们希望其中某个人能够到达下标最大的点. 每个角色只能进行下面的3种操作, 且每种操作不能每人不能进行超过一次. 1.移动一定的距离 2.把另一个角色高举过头 3.将举在头上的角色扔出一段距离 每个角色有一个movement range参数, 他们只能移动到没有人的位置, 并且起点和终点的距离不超过movement range. 如果角色A和另一个角色B距离为1, 并且角色B没有被别的角色举起, 那么A就能举起B. 同时, B会移动到A的位置,B原来所占的位置变为没有人的位置. 被举起的角色不能进行任何操作, 举起别人的角色不能移动.同时, 每个角色还有一个throwing range参数, 即他能把举起的角色扔出的最远的距离. 注意, 一个角色只能被扔到没有别的角色占据的位置. 我们认为一个角色举起另一个同样举起一个角色的角色是允许的. 这种情况下会出现3个人在同一个位置的情况. 根据前面的描述, 这种情况下上面的两个角色不能进行任何操作, 而最下面的角色可以同时扔出上面的两个角色. 你的任务是计算这些角色能够到达的位置的最大下标, 即最大的数字x, 使得存在一个角色能够到达x. 输入格式 输入共三行, 分别为Laharl, Etna, Floone的信息. 每一行有且仅有3个整数, 描述对应角色的初始位置, movement range, throwing range. 数据保证3个角色的初始位置两两不相同且所有的数字都在1到10之间. 输出格式 仅有1个整数, 即Laharl, Etna, Flonne之一能到达的最大距离. 样例输入 9 3 3 4 3 1 2 3 3 样例输出 15 样例说明 一开始Laharl在位置9, Etna在位置4, Flonne在位置2. 首先, Laharl移动到6. 然后Flonne移动到位置5并且举起Etna. Laharl举起Flonne将其扔到位置9. Flonne把Etna扔到位置12. Etna移动到位置15. 思路 这道题跟之前做过的 Curling 2.0 是同样的思路，用 DFS + 回溯去遍历所有可能的状态。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;stdio.h&gt;#include &lt;math.h&gt;using namespace std;struct State &#123; bool hasMoved; bool hasLifted; bool canThrow; bool able; State() &#123; hasMoved = false; hasLifted = false; canThrow = false; able = true; &#125;&#125;; State s[4];int pos[4]; //current positionint mr[4]; //move rangeint tr[4]; //throw rangeint p[4]; //lift which oneint res = 0;bool near(int s) &#123; for (int i = 1; i &amp;lt;= 3; i++) &#123; if (abs(pos[i] - s) == 1) &#123; return true; &#125; &#125; return false; &#125;void dfs() &#123; for (int i = 1; i &amp;lt;= 3; i++) &#123; res = max(res, pos[i]); &#125; for (int i = 1; i &amp;lt;= 3; i++) &#123; if (s[i].able == false) &#123; continue; &#125; if (s[i].hasMoved == false &amp;amp;&amp;amp; s[i].canThrow == false) &#123; for (int j = -mr[i]; j &amp;lt;= mr[i]; j++) &#123; if (j == 0) &#123; continue; &#125; pos[i] += j; s[i].hasMoved = true; if (near(pos[i]) || j == mr[i] || j == -mr[i]) &#123; dfs(); &#125; pos[i] -= j; s[i].hasMoved = false; &#125; &#125; if (s[i].hasLifted == false) &#123; for (int j = 1; j &amp;lt;= 3; j++) &#123; if (s[j].able == true &amp;amp;&amp;amp; abs(pos[i] - pos[j]) == 1) &#123; s[j].able = false; s[i].hasLifted = true; s[i].canThrow = true; p[i] = j; int temp = pos[j]; dfs(); pos[j] = temp; s[i].canThrow = false; s[i].hasLifted = false; s[j].able = true; &#125; &#125; &#125; if (s[i].canThrow) &#123; for (int j = -tr[i]; j &amp;lt;= tr[i]; j++) &#123; if (j == 0) &#123; continue; &#125; s[p[i]].able = true; s[i].canThrow = false; int temp = pos[p[i]]; pos[p[i]] = pos[i] + j; if (near(pos[p[i]]) || j == -tr[i] || j == tr[i]) &#123; dfs(); &#125; pos[p[i]] = temp; s[i].canThrow = true; s[p[i]].able = false; &#125; &#125; &#125; return;&#125;int main() &#123; for (int i = 1; i &amp;lt;= 3; i++) &#123; scanf(\"%d %d %d\", &amp;amp;pos[i], &amp;amp;mr[i], &amp;amp;tr[i]); &#125; dfs(); cout &amp;lt;&amp;lt; res; return 0; &#125; 1604924 ^ ^ Lift and Throw 04-02 14:23 2.572KB C++ 正确 100 1.187s 940.0KB&nbsp; &nbsp; 参考 算法训练 Lift and Throw (DFS &amp;&amp; 位运算)","categories":[],"tags":[]},{"title":"POJ 2139 Six Degrees of Cowvin Bacon 题解","slug":"poj-2139-six-degrees-of-cowvin-bacon","date":"2017-03-31T03:54:12.000Z","updated":"2017-12-09T15:33:26.974Z","comments":true,"path":"2017/03/31/poj-2139-six-degrees-of-cowvin-bacon/","link":"","permalink":"//carolunar.com/2017/03/31/poj-2139-six-degrees-of-cowvin-bacon/","excerpt":"POJ 2139 Six Degrees of Cowvin Bacon 题意“六度牛脉”理论：N 只奶牛组成了 M 个小圈子，每个小圈子内的奶牛到彼此的度为 1，如果两只奶牛 A 和 B 不在同一个圈子，但可以通过 C 认识（C 既和 A 在一个圈子，也和 B 在一个圈子 ），那么她们俩之间的度为 2，求哪只奶牛的牛脉最广，即到其他所有奶牛的度的平均数最小，乘 100 输出。 思路建图的时候把一个圈子内牛两两相连，就符合题意。接下来就是多源最短路径问题。","text":"POJ 2139 Six Degrees of Cowvin Bacon 题意“六度牛脉”理论：N 只奶牛组成了 M 个小圈子，每个小圈子内的奶牛到彼此的度为 1，如果两只奶牛 A 和 B 不在同一个圈子，但可以通过 C 认识（C 既和 A 在一个圈子，也和 B 在一个圈子 ），那么她们俩之间的度为 2，求哪只奶牛的牛脉最广，即到其他所有奶牛的度的平均数最小，乘 100 输出。 思路建图的时候把一个圈子内牛两两相连，就符合题意。接下来就是多源最短路径问题。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#define ONLINE_JUDGEusing namespace std;const int MAX_E = (301 * 300) / 2 + 4;const int MAX_N = 300 + 4;const int INF = 0x3f3f3f3f;typedef pair&lt;int, int&gt; Edge;vector&lt;pair&amp;lt;int, int&amp;gt; &gt; edge;int d[MAX_N];int cow[MAX_N];int N;int M;int BellmanFord(int s) &#123; fill(d, d + MAX_N, INF); d[s] = 0; while (true) &#123; bool update = false; for (int i = 0; i &amp;lt; edge.size(); i++) &#123; Edge e = edge[i]; if (d[e.first] != INF &amp;amp;&amp;amp; d[e.second] &amp;gt; d[e.first] + 1) &#123; update = true; d[e.second] = d[e.first] + 1; &#125; &#125; if (!update) &#123; break; &#125; &#125; int res = 0; for (int i = 0; i &amp;lt; N; i++) &#123; res += d[i + 1]; &#125; return res;&#125;int main() &#123; #ifndef ONLINE_JUDGE freopen(\"in.txt\", \"r\", stdin); #endif scanf(\"%d %d\", &amp;amp;N, &amp;amp;M); int num; for (int i = 0; i &amp;lt; M; i++) &#123; scanf(\"%d\", &amp;amp;num); for (int j = 0; j &amp;lt; num; j++) &#123; scanf(\"%d\", &amp;amp;cow[j]); &#125; for (int j = 0; j &amp;lt; num - 1; j++) &#123; for (int k = j + 1; k &amp;lt; num; k++) &#123; edge.push_back(Edge(cow[j], cow[k])); edge.push_back(Edge(cow[k], cow[j])); &#125; &#125; &#125; int minD = INF; for (int i = 0; i &amp;lt; N; i++) &#123; minD = min(minD, BellmanFord(i + 1)); &#125; printf(\"%d\", 100 * minD / (N - 1)); return 0;&#125; 8612476carolunarPOJ2139Accepted160.21511C++2017-03-31 11:32:51","categories":[],"tags":[]},{"title":"AOJ 0189 Convenient Location 题解","slug":"aoj-0189-convenient-location","date":"2017-03-31T03:24:18.000Z","updated":"2017-12-09T15:33:26.948Z","comments":true,"path":"2017/03/31/aoj-0189-convenient-location/","link":"","permalink":"//carolunar.com/2017/03/31/aoj-0189-convenient-location/","excerpt":"AOJ 0189 Convenient Location 题意如图所示，有若干个房子，给出一些边，权重代表两个房子间距离长度，求出哪个房子到其他所有房子的距离最短。 思路求任意两点间最短距离，我用了 Bellman-Ford，事实上用 Floyd 算法更好。","text":"AOJ 0189 Convenient Location 题意如图所示，有若干个房子，给出一些边，权重代表两个房子间距离长度，求出哪个房子到其他所有房子的距离最短。 思路求任意两点间最短距离，我用了 Bellman-Ford，事实上用 Floyd 算法更好。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;const int MAX_N = 45 * 2 + 4;const int MAX_V = 10 + 4;const int INF = 0x3f3f3f3f;int n;int v;struct Edge &#123; int from; int to; int cost;&#125; edge[MAX_N];int d[MAX_V];int Bellman_Ford (int s) &#123; int res = 0; fill(d, d + MAX_V, INF); d[s] = 0; while (true) &#123; bool update = false; for (int i = 0; i &amp;lt; 2 * n; i++) &#123; Edge e = edge[i]; if (d[e.from] != INF &amp;amp;&amp;amp; d[e.from] + e.cost &amp;lt; d[e.to]) &#123; d[e.to] = d[e.from] + e.cost; update = true; &#125; &#125; if (!update) &#123; break; &#125; &#125; for (int i = 0; i &amp;lt;= v; i++) &#123; res += d[i]; &#125; return res;&#125;int main() &#123; while (scanf(\"%d\", &amp;amp;n) &amp;amp;&amp;amp; n &amp;gt; 0) &#123; int path[MAX_V]; v = 0; for (int i = 0; i &amp;lt; n; i++) &#123; scanf(\"%d %d %d\", &amp;amp;edge[i].from, &amp;amp;edge[i].to, &amp;amp;edge[i].cost); edge[i + n].from = edge[i].to; edge[i + n].to = edge[i].from; edge[i + n].cost = edge[i].cost; v = max(v, edge[i].from); v = max(v, edge[i].to); &#125; for (int i = 0; i &amp;lt;= v; i++) &#123; path[i] = Bellman_Ford(i); &#125; printf(\"%d %d\\n\", min_element(path, path + v + 1) - path, *min_element(path, path + v + 1)); &#125; return 0; &#125;","categories":[],"tags":[]},{"title":"C++ 获取特定路径下所有文件的文件名","slug":"get-directory-listing-of-a-path-in-cpp","date":"2017-03-21T08:31:53.000Z","updated":"2017-12-09T15:31:04.296Z","comments":true,"path":"2017/03/21/get-directory-listing-of-a-path-in-cpp/","link":"","permalink":"//carolunar.com/2017/03/21/get-directory-listing-of-a-path-in-cpp/","excerpt":"","text":"#include #include #include #include using namespace std; void getFiles(string path, vector&amp; fileName) { intptr_t hFile = 0; _finddata_t fileInfo; string p; if ((hFile = _findfirst(p.assign(path).append(“\\*”).c_str(), &amp;fileInfo)) != -1) { do { if (fileInfo.attrib &amp; _A_SUBDIR) { if (strcmp(fileInfo.name, “.”) != 0 &amp;&amp; strcmp(fileInfo.name, “..”) != 0) { getFiles(p.assign(path).append(“\\“).append(fileInfo.name), fileName); } } else { fileName.push_back(p.assign(path).append(“\\“).append(fileInfo.name)); } } while (_findnext(hFile, &amp;fileInfo) == 0); _findclose(hFile); }} int main() { string path = “testDir”; vector fileName; getFiles(path, fileName); for (int i = 0; i &lt; fileName.size(); i++) { cout &lt;&lt; fileName[i] &lt;&lt; endl; } return 0;}``` &nbsp;","categories":[],"tags":[]},{"title":"CCF 201612-3 权限查询 题解","slug":"ccf-201612-3-authorization","date":"2017-03-18T14:04:17.000Z","updated":"2017-12-09T15:31:04.298Z","comments":true,"path":"2017/03/18/ccf-201612-3-authorization/","link":"","permalink":"//carolunar.com/2017/03/18/ccf-201612-3-authorization/","excerpt":"","text":"链接不好贴，直接把完整题目拷贝过来吧： 问题描述 授权 (authorization) 是各类业务系统不可缺少的组成部分，系统用户通过授权机制获得系统中各个模块的操作权限。 本题中的授权机制是这样设计的：每位用户具有若干角色，每种角色具有若干权限。例如，用户 david 具有 manager 角色，manager 角色有 crm:2 权限，则用户 david 具有 crm:2 权限，也就是 crm 类权限的第 2 等级的权限。 具体地，用户名和角色名称都是由小写字母组成的字符串，长度不超过 32。权限分为分等级权限和不分等级权限两大类。分等级权限由权限类名和权限等级构成，中间用冒号“:”分隔。其中权限类名也是由小写字母组成的字符串，长度不超过 32。权限等级是一位数字，从 0 到 9，数字越大表示权限等级越高。系统规定如果用户具有某类某一等级的权限，那么他也将自动具有该类更低等级的权限。例如在上面的例子中，除 crm:2 外，用户 david 也具有 crm:1 和 crm:0 权限。不分等级权限在描述权限时只有权限类名，没有权限等级（也没有用于分隔的冒号）。 给出系统中用户、角色和权限的描述信息，你的程序需要回答多个关于用户和权限的查询。查询可分为以下几类： 不分等级权限的查询：如果权限本身是不分等级的，则查询时不指定等级，返回是否具有该权限； 分等级权限的带等级查询：如果权限本身分等级，查询也带等级，则返回是否具有该类的该等级权限； 分等级权限的不带等级查询：如果权限本身分等级，查询不带等级，则返回具有该类权限的等级；如果不具有该类的任何等级权限，则返回“否”。 输入格式 输入第一行是一个正整数 p，表示不同的权限类别的数量。紧接着的 p 行被称为 P 段，每行一个字符串，描述各个权限。对于分等级权限，格式为 是该类权限的最高等级。对于不分等级权限，字符串只包含权限类名。 接下来一行是一个正整数 r，表示不同的角色数量。紧接着的 r 行被称为 R 段，每行描述一种角色，格式为 其中 个字符串描述该角色具有的权限，格式同 P 段。 接下来一行是一个正整数 u，表示用户数量。紧接着的 u 行被称为 U 段，每行描述一个用户，格式为 其中 个字符串描述该用户具有的角色。 接下来一行是一个正整数 q，表示权限查询的数量。紧接着的 q 行被称为 Q 段，每行描述一个授权查询，格式为 可指定等级，表示查询该用户是否具有该等级的权限；也可以不指定等级，表示查询该用户具有该权限的等级。对于不分等级权限，只能查询该用户是否具有该权限，查询中不能指定等级。 输出格式 输出共 q 行，每行为 false、true，或者一个数字。false 表示相应的用户不具有相应的权限，true 表示相应的用户具有相应的权限。对于分等级权限的不带等级查询，如果具有权限，则结果是一个数字，表示该用户具有该权限的（最高）等级。如果用户不存在，或者查询的权限没有定义，则应该返回 false。 样例输入 3 crm:2 git:3 game 4 hr 1 crm:2 it 3 crm:1 git:1 game dev 2 git:3 game qa 1 git:2 3 alice 1 hr bob 2 it qa charlie 1 dev 9 alice game alice crm:2 alice git:0 bob git bob poweroff charlie game charlie crm charlie git:3 malice game 样例输出 false true false 2 false true false true false 样例说明 样例输入描述的场景中，各个用户实际的权限如下： 用户 alice 具有 crm:2 权限 用户 bob 具有 crm:1、git:2 和 game 权限 用户 charlie 具有 git:3 和 game 权限 用户 malice 未描述，因此不具有任何权限 评测用例规模与约定 评测用例规模： 1 ≤ p, r, u ≤ 100 1 ≤ q ≤ 10 000 每个用户具有的角色数不超过 10，每种角色具有的权限种类不超过 10 约定： 输入保证合法性，包括： 1) 角色对应的权限列表（R 段）中的权限都是之前（P 段）出现过的，权限可以重复出现，如果带等级的权限重复出现，以等级最高的为准 2) 用户对应的角色列表（U 段）中的角色都是之前（R 段）出现过的，如果多个角色都具有某一分等级权限，以等级最高的为准 3) 查询（Q 段）中的用户名和权限类名不保证在之前（U 段和 P 段）出现过 前 20% 的评测用例只有一种角色 前 50% 的评测用例权限都是不分等级的，查询也都不带等级 &nbsp; 上次认证的题目，当时 C++ 太手生，数组都写不顺……自然没做出来。明天要再考一次，临时抱佛脚…做了一下，做出来了。 思路觉得没有涉及什么算法，是考对 C++ 的结构体/类/OO 的运用，以及脑子里自带的栈的使用…从来没有写过圈复杂度这么高的。 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;const int MAX_L = 32 + 4;const int MAX_N = 100 + 4;const int MAX_Q = 10000 + 4;int p;int r;int u;int q;class Privilege &#123;public: string category; int level; Privilege () &#123; &#125; Privilege (string input) &#123; char tempL = input[input.length() - 1]; if (tempL &lt;= '9' &amp;amp;&amp;amp; tempL &gt;= '0') &#123; category = input.substr(0, input.length() - 2); level = tempL - '0'; &#125; else &#123; category = input; level = -1; &#125; &#125;&#125; pri[MAX_N];struct Role &#123; string rolename; int s; Privilege myPri[MAX_N];&#125; role[MAX_N];struct User &#123; string username; int t; string myRole[MAX_N];&#125; user[MAX_N];struct Query &#123; string username; Privilege myPri;&#125; query[MAX_Q];int main() &#123; scanf(\"%d\", &amp;amp;p); for (int i = 0; i &amp;lt; p; i++) &#123; string tempP; cin &amp;gt;&amp;gt; tempP; Privilege temp(tempP); pri[i] = temp; &#125; scanf(\"%d\", &amp;amp;r); for (int i = 0; i &amp;lt; r; i++) &#123; cin &amp;gt;&amp;gt; role[i].rolename &amp;gt;&amp;gt; role[i].s; for (int j = 0; j &amp;lt; role[i].s; j++) &#123; string tempP; cin &amp;gt;&amp;gt; tempP; Privilege temp(tempP); role[i].myPri[j] = temp; &#125; &#125; scanf(\"%d\", &amp;amp;u); for (int i = 0; i &amp;lt; u; i++) &#123; cin &amp;gt;&amp;gt; user[i].username &amp;gt;&amp;gt; user[i].t; for (int j = 0; j &amp;lt; user[i].t; j++) &#123; cin &amp;gt;&amp;gt; user[i].myRole[j]; &#125; &#125; scanf(\"%d\", &amp;amp;q); for (int i = 0; i &amp;lt; q; i++) &#123; string tempP; cin &amp;gt;&amp;gt; query[i].username &amp;gt;&amp;gt; tempP; Privilege temp(tempP); query[i].myPri = temp; bool validUser = false; bool validPri = false; bool done = false; for (int j = 0; j &amp;lt; u; j++) &#123; if (user[j].username == query[i].username) &#123; validUser = true; int maxLevel = -1; for (int k = 0; k &amp;lt; user[j].t; k++) &#123; if (done) &#123; break; &#125; for (int x = 0; x &amp;lt; r; x++) &#123; if (role[x].rolename == user[j].myRole[k]) &#123; for (int y = 0; y &amp;lt; role[x].s; y++) &#123; if (role[x].myPri[y].category == query[i].myPri.category) &#123; validPri = true; if (role[x].myPri[y].level == -1) &#123; cout &amp;lt;&amp;lt; \"true\" &amp;lt;&amp;lt; endl; done = true; break; &#125; else if (role[x].myPri[y].level &amp;gt; -1) &#123; maxLevel = max(maxLevel, role[x].myPri[y].level); &#125; &#125; &#125; &#125; &#125; &#125; if (!done &amp;amp;&amp;amp; validPri) &#123; if (query[i].myPri.level == -1) &#123; cout &amp;lt;&amp;lt; maxLevel &amp;lt;&amp;lt; endl; &#125; else if (query[i].myPri.level &amp;lt;= maxLevel) &#123; cout &amp;lt;&amp;lt; \"true\" &amp;lt;&amp;lt; endl; &#125; else &#123; cout &amp;lt;&amp;lt; \"false\" &amp;lt;&amp;lt; endl; &#125; &#125; &#125; &#125; if (!validUser || !validPri) &#123; cout &amp;lt;&amp;lt; \"false\" &amp;lt;&amp;lt; endl; &#125; &#125; return 0;&#125; 知识水平C++ String 类自带的截取函数：substring(index, length). 表示从 index 表示的位置开始截取长度为 length 的字符。 另外从这道题开始把数组多开的那几个直接写到预定义的 MAX 值里面了，更直观也更方便。 提交编号试题名称提交时间代码长度编程语言评测结果得分时间使用空间使用325436权限查询03-17 22:023.621KBC++正确100203ms4.382MB","categories":[],"tags":[]},{"title":"UVA 10004 Bicoloring 题解","slug":"uva-10004-bicoloring","date":"2017-03-18T13:53:49.000Z","updated":"2017-12-09T15:31:04.384Z","comments":true,"path":"2017/03/18/uva-10004-bicoloring/","link":"","permalink":"//carolunar.com/2017/03/18/uva-10004-bicoloring/","excerpt":"","text":"UVA 10004 Bicoloring 题意给定一张图，求是否能二分着色。 思路纯基础的二分图问题，本来是因为上道题一直 WA 才找了这道题来写的。写着写着果然就明白 bug 在哪里了。上道题没有及时 return，导致如果有非连通图存在的话，只要有一个图可以着色就会返回 true，而实际上应该是 false. AC代码// 这种写法不用考虑是否是连通图的问题。都可以得出正确结果。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stdio.h&gt;#include &lt;memory.h&gt;using namespace std;const int MAX_N = 200 + 4;int n;int l;vector&lt;int&gt; G[MAX_N];int color[MAX_N];bool dfs(int v, int c) &#123; color[v] = c; for (int i = 0; i &amp;lt; G[v].size(); i++) &#123; if (color[G[v][i]] == c) &#123; return false; &#125; if (color[G[v][i]] == 0 &amp;amp;&amp;amp; !dfs(G[v][i], -c)) &#123; return false; &#125; &#125; return true;&#125;bool solve() &#123; for (int i = 0; i &amp;lt; n; i++) &#123; if (color[i] == 0) &#123; if (!dfs(i, 1)) &#123; return false; &#125; &#125; &#125; return true;&#125;int main () &#123; while(scanf(\"%d\", &amp;amp;n) &amp;amp;&amp;amp; n &amp;gt; 0) &#123; for (int i = 0; i &amp;lt; MAX_N; i++) &#123; G[i].clear(); &#125; memset(color, 0, sizeof(color)); scanf(\"%d\", &amp;amp;l); int a; int b; for (int i = 0; i &amp;lt; l; i++) &#123; scanf(\"%d %d\", &amp;amp;a, &amp;amp;b); G[a].push_back(b); G[b].push_back(a); &#125; if (solve()) &#123; printf(\"BICOLORABLE.\\n\"); &#125; else &#123; printf(\"NOT BICOLORABLE.\\n\"); &#125; &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"ACdream 1056 Bad Horse 题解","slug":"acdream-1056-bad-horse","date":"2017-03-18T13:45:26.000Z","updated":"2017-12-09T15:31:04.353Z","comments":true,"path":"2017/03/18/acdream-1056-bad-horse/","link":"","permalink":"//carolunar.com/2017/03/18/acdream-1056-bad-horse/","excerpt":"题目大意大王有很多手下，然而其中好多人都两两不和。给定所有不共戴天的人的名单，你的任务是帮大王求出是否能把这些人完全分成两派，让那些不和的人不必见面。 思路二分图的练习题。用邻接表表示图，用染色法判断是否是二分图。","text":"题目大意大王有很多手下，然而其中好多人都两两不和。给定所有不共戴天的人的名单，你的任务是帮大王求出是否能把这些人完全分成两派，让那些不和的人不必见面。 思路二分图的练习题。用邻接表表示图，用染色法判断是否是二分图。 注意STL 容器在不同的 case 里重复利用的时候记得初始化。 AC 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;const int MAX_M = 100 + 4; int T;int M;struct Member &#123; string name; vector&lt;string&gt; edge; int color;&#125;;vector&lt;Member&gt; member;void init(string node1, string node2) &#123; bool found = false; for (int j = 0; j &amp;lt; member.size(); j++) &#123; if (member[j].name == node1) &#123; member[j].edge.push_back(node2); found = true; break; &#125; &#125; if (!found) &#123; Member temp; temp.name = node1; temp.edge.push_back(node2); temp.color = 0; member.push_back(temp); &#125;&#125;bool dfs(int v, int c) &#123; member[v].color = c; int index; for (int i = 0; i &amp;lt; member[v].edge.size(); i++) &#123; for (int j = 0; j &amp;lt; member.size(); j++) &#123; if (member[j].name == member[v].edge[i]) &#123; index = j; break; &#125; &#125; if (member[index].color == c) &#123; return false; &#125; if (member[index].color == 0 &amp;amp;&amp;amp; !dfs(index, -c)) &#123; return false; &#125; &#125; return true;&#125;bool solve() &#123; for (int i = 0; i &amp;lt; member.size(); i++) &#123; if (member[i].color == 0) &#123; if (!dfs(i, 1)) &#123; return false; &#125; &#125; &#125; return true;&#125;int main() &#123; scanf(\"%d\", &amp;amp;T); for (int t = 1; t &amp;lt;= T; t++) &#123; bool res; scanf(\"%d\", &amp;amp;M); for (int i = 0; i &amp;lt; member.size(); i++) &#123; member[i].edge.clear(); &#125; member.clear(); string first; string second; for (int i = 0; i &amp;lt; M; i++) &#123; cin &amp;gt;&amp;gt; first &amp;gt;&amp;gt; second; init(first, second); init(second, first); &#125; if (solve()) &#123; printf(\"Case #%d: Yes\\n\", t); &#125; else &#123; printf(\"Case #%d: No\\n\", t); &#125; &#125; return 0;&#125; //0318按：据说可以用 map 直接把 string 映射成整数，会方便许多。机智的我发现自己实现了一遍 map 的初始化以及查找？暂作阙疑，以后再优化。","categories":[],"tags":[]},{"title":"AOJ 2170 Marked Ancestor 题解","slug":"aoj-2170-marked-ancestor","date":"2017-03-18T13:36:00.000Z","updated":"2017-12-09T15:31:04.413Z","comments":true,"path":"2017/03/18/aoj-2170-marked-ancestor/","link":"","permalink":"//carolunar.com/2017/03/18/aoj-2170-marked-ancestor/","excerpt":"","text":"AOJ 2170 Marked Ancestor 题目大意给定一棵树，开始只有根节点被标记，其他结点都未被标记。有两种操作，一种是标记某个结点，另一种是查距离某个结点最近的祖先结点（ancestor）。输出每次查询所得结果的和。 思路设置一个标记变量 marked，结点 i 被标记后就将 marked[i] 置 1。查询时用并查集里的 find 操作寻找其祖先结点。 注意 一个结点的祖先结点包括其自身，子孙结点也包括其自身~~~ AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;memory.h&gt;using namespace std;const int MAX_N = 100000;int N;int Q;bool marked[MAX_N + 4];int par[MAX_N + 4];int find(int x) &#123; if (marked[x] == true) &#123; return x; &#125; return find(par[x]);&#125;int main() &#123; while (scanf(\"%d %d\", &amp;amp;N, &amp;amp;Q) != EOF &amp;amp;&amp;amp; N &amp;gt; 0 &amp;amp;&amp;amp; Q &amp;gt; 0) &#123; memset(marked, 0, sizeof(marked)); marked[1] = 1; long long res = 0; for (int i = 2; i &amp;lt;= N; i++) &#123; scanf(\"%d\", &amp;amp;par[i]); &#125; par[1] = 1; cin.ignore(); char operation; int node; for (int i = 0; i &amp;lt; Q; i++) &#123; scanf(\"%c %d\", &amp;amp;operation, &amp;amp;node); if (operation == 'Q') &#123; res += find(node); &#125; else if (operation == 'M') &#123; marked[node] = true; &#125; cin.ignore(); &#125; cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; endl; &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"POJ 1703 Find them, Catch them 题解","slug":"poj-1703-find-them-catch-them","date":"2017-03-18T03:35:40.000Z","updated":"2017-12-09T15:31:04.337Z","comments":true,"path":"2017/03/18/poj-1703-find-them-catch-them/","link":"","permalink":"//carolunar.com/2017/03/18/poj-1703-find-them-catch-them/","excerpt":"","text":"POJ Find them, Catch them 题目大意有两拨坏人，龙帮和蛇帮，干了很多坏事。现在只知道某两件坏事不是同一个帮干的。先给一些描述，最后查询某两件事是否是同一帮干的。 思路食物链的简化版。2 * N 个元素，1 - N 表示属于龙帮，N + 1 到 2N 表示属于蛇帮。D 操作的时候将相应的编号加入并查集中的一个组， A操作的时候查询是否属于同一个组。 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;const int MAX_N = 100000;int T;int N;int M;int par[MAX_N * 2 + 4];int rank[MAX_N * 2 + 4];void init(int n) &#123; for (int i = 0; i &amp;lt; n; i++) &#123; par[i] = i; rank[i] = 0; &#125;&#125;int find(int x) &#123; if (par[x] == x) &#123; return x; &#125; return par[x] = find(par[x]);&#125;void unite(int x, int y) &#123; x = find(x); y = find(y); if (x == y) &#123; return; &#125; if (rank[x] &amp;lt; rank[y]) &#123; par[x] = y; &#125; else &#123; par[y] = x; if (rank[x] == rank[y]) &#123; rank[x]++; &#125; &#125;&#125;bool same(int x, int y) &#123; return find(x) == find(y);&#125;int main() &#123; scanf(\"%d\", &amp;amp;T); while (T--) &#123; scanf(\"%d %d\", &amp;amp;N, &amp;amp;M); init(N * 2); char message; int a; int b; cin.ignore(); for (int i = 0; i &amp;lt; M; i++) &#123; scanf(\"%c %d %d\", &amp;amp;message, &amp;amp;a, &amp;amp;b); a--; b--; if (message == 'D') &#123; unite(a, b + N); unite(a + N, b); &#125; else &#123; if (same(a, b)) &#123; printf(\"In the same gang. \\n\"); &#125; else if (same(a, b + N)) &#123; printf(\"In different gangs.\\n\"); &#125; else &#123; printf(\"Not sure yet.\\n\"); &#125; &#125; cin.ignore(); &#125; &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"POJ 2236 Wireless Network 题解","slug":"poj-2236-wireless-network","date":"2017-03-15T14:20:06.000Z","updated":"2017-12-09T15:31:04.405Z","comments":true,"path":"2017/03/15/poj-2236-wireless-network/","link":"","permalink":"//carolunar.com/2017/03/15/poj-2236-wireless-network/","excerpt":"","text":"POJ 2236 Wireless Network 题目大意程序员要修电脑。N 台电脑位于不同的坐标，距离 d 内且被修好的电脑可以互联。给定每台电脑的坐标（coordinate，刚开始不认识这个词），然后开始修，修着修着检测一下 p，q 两台能不能互联。求每次检测的结果。 思路互联的先决条件是距离近，因此刚开始用数组 reach[i][j] 保存每两台电脑是否够近。接下来每次修好一台电脑，就将其与所有方圆 d 米内且已经修好的电脑加入并查集的同一小组。检测的时候检测是否为同一小组就好了。 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;memory.h&gt;using namespace std;const int MAX_N = 1001;int N;int d;int x[MAX_N + 4];int y[MAX_N + 4];bool repaired[MAX_N + 4];bool reach[MAX_N +4][MAX_N + 4];int par[MAX_N + 4];int rank[MAX_N + 4];void init(int n) &#123; for (int i = 0; i &amp;lt; n; i++) &#123; par[i] = i; rank[i] = 0; &#125;&#125;int find(int x) &#123; if (par[x] == x) &#123; return x; &#125; return par[x] = find(par[x]);&#125;void unite(int x, int y) &#123; x = find(x); y = find(y); if (x == y) &#123; return; &#125; if (rank[x] &amp;lt; rank[y]) &#123; par[x] = y; &#125; else &#123; par[y] = x; if (rank[x] == rank[y]) &#123; rank[x]++; &#125; &#125;&#125;bool same(int x, int y) &#123; return find(x) == find(y);&#125;int main() &#123; scanf(\"%d %d\", &amp;amp;N, &amp;amp;d); init(N + 1); for (int i = 1; i &amp;lt;= N; i++) &#123; scanf(\"%d %d\", &amp;amp;x[i], &amp;amp;y[i]); &#125; for (int i = 1; i &amp;lt;= N; i++) &#123; for (int j = i + 1; j &amp;lt;= N; j++) &#123; if (sqrt((double)((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]))) &amp;lt;= d) &#123; reach[i][j] = true; reach[j][i] = true; &#125; &#125; &#125; cin.ignore(); char operation; while (scanf(\"%c\", &amp;amp;operation) != EOF) &#123; if (operation == 'O') &#123; int x; scanf(\"%d\", &amp;amp;x); repaired[x] = true; for (int i = 1; i &amp;lt;= N; i++) &#123; if (i == x) &#123; continue; &#125; if (reach[x][i] &amp;amp;&amp;amp; repaired[i]) &#123; unite(i, x); &#125; &#125; &#125; else if (operation == 'S') &#123; int p; int q; scanf(\"%d %d\", &amp;amp;p, &amp;amp;q); if (same(p, q)) &#123; printf(\"SUCCESS\\n\"); &#125; else &#123; printf(\"FAIL\\n\"); &#125; &#125; cin.ignore(); &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"POJ 1182 食物链 题解","slug":"poj-1182-food-cycle","date":"2017-03-15T14:13:00.000Z","updated":"2017-12-09T15:33:26.938Z","comments":true,"path":"2017/03/15/poj-1182-food-cycle/","link":"","permalink":"//carolunar.com/2017/03/15/poj-1182-food-cycle/","excerpt":"POJ 1182 食物链 题目大意动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B， B吃C，C吃A。现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。有人用两种说法对这N个动物所构成的食物链关系进行描述：第一种说法是”1 X Y”，表示X和Y是同类。第二种说法是”2 X Y”，表示X吃Y。此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。1） 当前的话与前面的某些真的话冲突，就是假话；2） 当前的话中X或Y比N大，就是假话；3） 当前的话表示X吃X，就是假话。你的任务是根据给定的N（1 &lt;= N &lt;= 50,000）和K句话（0 &lt;= K &lt;= 100,000），输出假话的总数。 思路并查集这一节中的例题。一上来就是高级应用哇。比普通的求连通否段位高好多的样子。 在这里，并查集中的元素不是动物，而是事件，或者说，是命题。用 i, 2i, 3i 分别表示 i 属于 A, i 属于 B, i 属于 C, 这样并查集里每一组表示组内所有元素代表的命题同时发生或不发生。","text":"POJ 1182 食物链 题目大意动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B， B吃C，C吃A。现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。有人用两种说法对这N个动物所构成的食物链关系进行描述：第一种说法是”1 X Y”，表示X和Y是同类。第二种说法是”2 X Y”，表示X吃Y。此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。1） 当前的话与前面的某些真的话冲突，就是假话；2） 当前的话中X或Y比N大，就是假话；3） 当前的话表示X吃X，就是假话。你的任务是根据给定的N（1 &lt;= N &lt;= 50,000）和K句话（0 &lt;= K &lt;= 100,000），输出假话的总数。 思路并查集这一节中的例题。一上来就是高级应用哇。比普通的求连通否段位高好多的样子。 在这里，并查集中的元素不是动物，而是事件，或者说，是命题。用 i, 2i, 3i 分别表示 i 属于 A, i 属于 B, i 属于 C, 这样并查集里每一组表示组内所有元素代表的命题同时发生或不发生。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;const int MAX_N = 50000;const int MAX_K = 100000;int N;int K;int D;int X;int Y;//并查集 int par[MAX_N * 3 + 4];int rank[MAX_N * 3 + 4];//初始化n个元素 void init(int n) &#123; for (int i = 0; i &amp;lt; n; i++) &#123; par[i] = i; rank[i] = 0; &#125;&#125;//查询树的根int find(int x) &#123; if (par[x] == x) &#123; return x; &#125; return par[x] = find(par[x]);&#125; //合并x和y所属的集合void unite(int x, int y) &#123; x = find(x); y = find(y); if (x == y) &#123; return; &#125; if (rank[x] &amp;lt; rank[y]) &#123; par[x] = y; &#125; else &#123; par[y] = x; if (rank[x] == rank[y]) &#123; rank[x]++; &#125; &#125;&#125; //判断x和y是否属于同一个集合bool same(int x, int y) &#123; return find(x) == find(y);&#125; int main() &#123; scanf(\"%d %d\", &amp;amp;N, &amp;amp;K); init(N * 3); int ans = 0; for (int i = 0; i &amp;lt; K; i++) &#123; scanf(\"%d %d %d\", &amp;amp;D, &amp;amp;X, &amp;amp;Y); X--; Y--; if (X &lt; 0 || X &amp;gt;= N || Y &amp;lt; 0 || Y &gt;= N) &#123; ans++; continue; &#125; if (D == 1) &#123; if (same(X, Y + N) || same(X, Y + 2 * N)) &#123; ans++; &#125; else &#123; unite(X, Y); unite(X + N, Y + N); unite(X + 2 * N, Y + 2 * N); &#125; &#125; else &#123; if (same(X, Y) || same(X, Y + 2 * N)) &#123; ans++; &#125; else &#123; unite(X, Y + N); unite(X + N, Y + 2 * N); unite(X + 2 * N, Y); &#125; &#125; &#125; printf(\"%d\", ans); return 0;&#125;","categories":[],"tags":[]},{"title":"POJ 2010 Moo University - Financial Aid 题解","slug":"poj-2010-moo-university-financial-aid","date":"2017-03-15T02:39:19.000Z","updated":"2017-12-09T15:31:04.360Z","comments":true,"path":"2017/03/15/poj-2010-moo-university-financial-aid/","link":"","permalink":"//carolunar.com/2017/03/15/poj-2010-moo-university-financial-aid/","excerpt":"","text":"POJ 2010 Moo University - Financial Aid 题目大意Bessie 办了一个奶牛大学，要从 C 只奶牛中招 N 只上学。每只奶牛的高考分数和需要的助学金不同，Bessie 希望所有学生分数的中位数尽可能高，同时只有 F 元的助学金可以发。求最大的中位数是多少。 思路先对奶牛按分数排序，只有分数处于中间的一部分奶牛才有可能是中位数。遍历这些奶牛，算出每一只作为中位数时，比它分数低的奶牛所需要的最少助学金 lower[i], 比它分数高的奶牛所需要的最少助学金 upper[i]。最后根据分数从大到小遍历这些奶牛，满足 lower[i] + 助学金[i] + upper[i] &lt;= F 的第一只奶牛，即为答案。 这道题对优先队列的使用在于求 lower[i] 和 upper [i] 的时候，这也是我没有想的很好的地方。起初我对每只奶牛都建立了一个最小优先队列，把其前面的所有牛的助学金都放进去，再出队 C/2 个，自以为很厉害，可以说是熟练运用优先队列了呢，这次收到了来自 TLE 的无声嘲讽，还是图样。 更优的做法是只建立一个优先队列，因为每次也只有一个值可能被更新。看代码吧~ AC 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;functional&gt;using namespace std;const int MAX_C = 100000;int N;int C;int F;pair&lt;int, int&gt; cow[MAX_C + 4];int lower[MAX_C + 4];int upper[MAX_C + 4];int main() &#123; scanf(\"%d %d %d\", &amp;amp;N, &amp;amp;C, &amp;amp;F); for (int i = 0; i &amp;lt; C; i++) &#123; scanf(\"%d %d\", &amp;amp;cow[i].first, &amp;amp;cow[i].second); &#125; sort(cow, cow + C); int first = N / 2; int last = C - first - 1; priority_queue&lt;int&gt; que; int total = 0; for (int i = 0; i &amp;lt; first; i++) &#123; total += cow[i].second; que.push(cow[i].second); &#125; for (int i = first; i &amp;lt;= last; i++) &#123; lower[i] = total; int aid = cow[i].second; int top = que.top(); if (aid &amp;lt; top) &#123; que.pop(); que.push(aid); total = total - top + aid; &#125; &#125; while (que.size()) &#123; que.pop(); &#125; total = 0; for (int i = last + 1; i &amp;lt; C; i++) &#123; total += cow[i].second; que.push(cow[i].second); &#125; for (int i = last; i &amp;gt;= first; i--) &#123; upper[i] = total; int aid = cow[i].second; int top = que.top(); if (aid &amp;lt; top) &#123; que.pop(); que.push(aid); total = total - top + aid; &#125; &#125; int res = -1; for (int i = last; i &amp;gt;= first; i--) &#123; if (lower[i] + cow[i].second + upper[i] &amp;lt;= F) &#123; res = cow[i].first; break; &#125; &#125; cout &amp;lt;&amp;lt; res; return 0;&#125;","categories":[],"tags":[]},{"title":"POJ 3614 Sunscreen 题解","slug":"poj-3614-sunscreen","date":"2017-03-14T08:17:36.000Z","updated":"2017-12-09T15:33:26.952Z","comments":true,"path":"2017/03/14/poj-3614-sunscreen/","link":"","permalink":"//carolunar.com/2017/03/14/poj-3614-sunscreen/","excerpt":"POJ 3614 Sunscreen 题目大意奶牛们晒日光浴要擦防晒霜。防晒霜有不同的 SPF 度数，每个奶牛的肤质不同所以要用不同度数的防晒霜，度数太高相当于白晒了，太低的话会晒伤。给定奶牛总数、每只奶牛可以使用的防晒霜度数区间 [minSPFi , maxSPFi]、每种防晒霜的度数和瓶数，求最多可以让多少只奶牛美美地晒上日光浴。 思路已知这道题用优先队列可以得到较好的解，因为是优先队列的课后习题…… 之前一直在做 DP，思维都僵化了Θ_Θ。刚开始遍历了奶牛，把防晒霜装进了优先队列里。自以为很厉害了，然而收到了来自 WA 的无声嘲讽。 核心思想就是“在可以用第 i 瓶防晒霜的所有奶牛中，给最挑剔的奶牛那只先用”。因此每次都放所有可能用这瓶防晒霜的奶牛进入队列，然后让右边界最小的先出队。","text":"POJ 3614 Sunscreen 题目大意奶牛们晒日光浴要擦防晒霜。防晒霜有不同的 SPF 度数，每个奶牛的肤质不同所以要用不同度数的防晒霜，度数太高相当于白晒了，太低的话会晒伤。给定奶牛总数、每只奶牛可以使用的防晒霜度数区间 [minSPFi , maxSPFi]、每种防晒霜的度数和瓶数，求最多可以让多少只奶牛美美地晒上日光浴。 思路已知这道题用优先队列可以得到较好的解，因为是优先队列的课后习题…… 之前一直在做 DP，思维都僵化了Θ_Θ。刚开始遍历了奶牛，把防晒霜装进了优先队列里。自以为很厉害了，然而收到了来自 WA 的无声嘲讽。 核心思想就是“在可以用第 i 瓶防晒霜的所有奶牛中，给最挑剔的奶牛那只先用”。因此每次都放所有可能用这瓶防晒霜的奶牛进入队列，然后让右边界最小的先出队。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;queue&gt;#include &lt;functional&gt;#include &lt;algorithm&gt;using namespace std;const int MAX_C = 2500;const int MAX_L = 2500;int C;int L;pair&lt;int, int&gt; cow[MAX_C + 4];pair&lt;int, int&gt; lotion[MAX_L + 4];int main() &#123; scanf(\"%d %d\", &amp;amp;C, &amp;amp;L); for (int i = 0; i &amp;lt; C; i++) &#123; scanf(\"%d %d\", &amp;amp;cow[i].first, &amp;amp;cow[i].second); &#125; priority_queue&lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt; &gt; que; for (int i = 0; i &amp;lt; L; i++) &#123; scanf(\"%d %d\", &amp;amp;lotion[i].first, &amp;amp;lotion[i].second); &#125; sort(cow, cow + C); sort(lotion, lotion + L); int res = 0; int cur = 0; for (int i = 0; i &amp;lt; L; i++) &#123; while (cur &amp;lt; C &amp;amp;&amp;amp; cow[cur].first &amp;lt;= lotion[i].first) &#123; que.push(cow[cur].second); cur++; &#125; while (!que.empty() &amp;amp;&amp;amp; lotion[i].second) &#123; int maxSPF = que.top(); que.pop(); if (maxSPF &amp;gt;= lotion[i].first) &#123; res++; lotion[i].second--; &#125; &#125; &#125; cout &amp;lt;&amp;lt; res; return 0;&#125; &nbsp;","categories":[],"tags":[]},{"title":"POJ 2431 Expedition 题解","slug":"poj-2431-expedition","date":"2017-03-10T08:15:55.000Z","updated":"2017-12-09T15:33:26.943Z","comments":true,"path":"2017/03/10/poj-2431-expedition/","link":"","permalink":"//carolunar.com/2017/03/10/poj-2431-expedition/","excerpt":"POJ 2431 Expedition 题意车子坏了，奶牛们要去修理厂修车。油箱里的汽油每公斤只能走一公里，初始距离修理厂 L 公里，有 P 公斤汽油。沿途有 N 个加油站，距离修理厂的距离以及可以加的汽油量各异。车子虽破，但却有一个巨大的油箱，想加多少就加多少。求车能不能开到修理厂，能的话求出最少加油次数，否则输出 -1 。 思路这是书上 2.4 加工并存储的数据结构 这一节的例题。用优先队列。 优先队列是一种特殊的队列。普通的队列中，元素进入就排到队尾，出的话队头先出。优先队列是有优先权的元素先出，同样，一个元素进入的时候，就按其优先权排到自己该有的位置，就像做人一样，要搞清楚自己的定位。","text":"POJ 2431 Expedition 题意车子坏了，奶牛们要去修理厂修车。油箱里的汽油每公斤只能走一公里，初始距离修理厂 L 公里，有 P 公斤汽油。沿途有 N 个加油站，距离修理厂的距离以及可以加的汽油量各异。车子虽破，但却有一个巨大的油箱，想加多少就加多少。求车能不能开到修理厂，能的话求出最少加油次数，否则输出 -1 。 思路这是书上 2.4 加工并存储的数据结构 这一节的例题。用优先队列。 优先队列是一种特殊的队列。普通的队列中，元素进入就排到队尾，出的话队头先出。优先队列是有优先权的元素先出，同样，一个元素进入的时候，就按其优先权排到自己该有的位置，就像做人一样，要搞清楚自己的定位。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;const int MAX_N = 10000;int N;pair&lt;int, int&gt; stop[MAX_N + 4];int L;int P;void solve() &#123; priority_queue&lt;int&gt; que; stop[N].first = L; stop[N].second = 0; N++; int ans = 0; int pos = 0; int tank = P; for (int i = 0; i &amp;lt; N; i++) &#123; int d = stop[i].first - pos; //distance to next fuel stop while (tank &amp;lt; d) &#123; if (que.empty()) &#123; printf(\"-1\"); return; &#125; tank += que.top(); que.pop(); ans++; &#125; tank -= d; pos = stop[i].first; que.push(stop[i].second); &#125; printf(\"%d\", ans);&#125;int main() &#123; scanf(\"%d\", &amp;amp;N); for (int i = 0; i &amp;lt; N; i++) &#123; scanf(\"%d %d\", &amp;amp;stop[i].first, &amp;amp;stop[i].second); &#125; scanf(\"%d %d\", &amp;amp;L, &amp;amp;P); for (int i = 0; i &amp;lt; N; i++) &#123; stop[i].first = L - stop[i].first; //将距终点的距离改为距起点的距离，方便之后操作 &#125; sort(stop, stop + N); solve(); return 0;&#125;","categories":[],"tags":[]},{"title":"POJ 1631 Bridging signals 题解","slug":"poj-1631-bridging-signals","date":"2017-03-10T07:39:49.000Z","updated":"2017-12-09T15:31:04.342Z","comments":true,"path":"2017/03/10/poj-1631-bridging-signals/","link":"","permalink":"//carolunar.com/2017/03/10/poj-1631-bridging-signals/","excerpt":"","text":"POJ 1631 Bridging signals 题意铺垫太长以至于看了好久才懂……有人把电路板上的电线弄乱了，如左图。只有相互不交叉的电线才是可用的。给出和左边 1-p 连线的右边的端口顺序，求最多有多少条电线可用。 思路虽然铺垫了这么多，但本质上就是求最长上升子序列的长度的问题。只要右边的顺序上升的话，电线就不会缠在一起。 一开始并没有想到，做完前一道题加提醒加背代码……很快写完了。 还是要多学习一个，这样才能跟不同的人谈笑风生，啊不，见到不同的题才能抓住本质。 AC代码123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;const int MAX_P = 40000;const int INF = 0x3f3f3f3f;int n;int p;int port[MAX_P + 4];int dp[MAX_P + 4];int main() &#123; scanf(\"%d\", &amp;amp;n); while (n--) &#123; scanf(\"%d\", &amp;amp;p); for (int i = 0; i &amp;lt; p; i++) &#123; scanf(\"%d\", &amp;amp;port[i]); dp[i] = INF; &#125; for (int i = 0; i &amp;lt; p; i++) &#123; *lower_bound(dp, dp + p, port[i]) = port[i]; &#125; cout &amp;lt;&amp;lt; lower_bound(dp, dp + p, INF) - dp &amp;lt;&amp;lt; endl; &#125; return 0;&#125; 8389690carolunarPOJ1631Accepted125ms0.5MB580BC++2017-03-10 15:30:05","categories":[],"tags":[]},{"title":"POJ 1065 Wooden Sticks 题解","slug":"poj-1065-wooden-sticks","date":"2017-03-10T03:48:18.000Z","updated":"2017-12-09T15:31:04.332Z","comments":true,"path":"2017/03/10/poj-1065-wooden-sticks/","link":"","permalink":"//carolunar.com/2017/03/10/poj-1065-wooden-sticks/","excerpt":"","text":"POJ 1065 Wooden Sticks 题目大意有 n 根木棒，每根长度为 l，质量为 w。用一台机器加工这些木棒，刚开始需要 1 分钟的启动时间，接下来，如果每次加工的木棒比前一根长且重的话，就可以不停歇继续加工，否则就需要 1 分钟的清洗时间。给定 n 根木棒的长度和质量，求最短的加工时间。 思路最短加工时间实际上相当于 n 根木棒按长度排序后，质量序列的最长下降子序列的长度。或者反过来也可，即对质量排序后，长度序列的 LDS 的长度。 参考最长上升子序列的解决方法，书上 65 页例题所讲。 令 dp[i] 表示长度为 i + 1 的最长下降子序列中末尾元素的最大值（不存在这一长度的 LDS 的话，就是 - 1）。这样做是因为，如果子序列的长度相同，那么末尾元素更大的，在之后会更有优势，可以收更多比它小的当小弟。 就好像要从 100 个顺序固定而高矮不一的人中，挑出尽可能多的人排成一支高度递减的队伍，那么每个人都要和前面所有被挑中的作比较。比如已经选出了一个一米九和一米七的，后面又发现了一米八的小明，那么就把小明作为第二位。处处留心皆学问呀，算法无处不在&gt; &lt; AC代码1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;memory.h&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;using namespace std;const int MAX_N = 5000;int T;int n;pair&lt;int, int&gt; stick[MAX_N + 4];int dp[MAX_N + 4];int main() &#123; scanf(\"%d\", &amp;amp;T); while (T--) &#123; scanf(\"%d\", &amp;amp;n); for (int i = 0; i &amp;lt; n; i++) &#123; scanf(\"%d %d\", &amp;amp;stick[i].first, &amp;amp;stick[i].second); &#125; sort(stick, stick + n); memset(dp, -1, sizeof(dp)); for (int i = 0; i &amp;lt; n; i++) &#123; *lower_bound(dp, dp + n, stick[i].second, greater&lt;int&gt; ()) = stick[i].second; //若某 dp &amp;lt; stick[i].second，将其更新为这个值 &#125; cout &lt;&amp;lt; lower_bound(dp, dp + n, -1, greater&amp;lt;int&gt; ()) - dp &amp;lt;&amp;lt; endl; &#125; return 0;&#125; 8388237 carolunar POJ 1065 Accepted 16ms 0.2MB 722B C++ 2017-03-10 11:16:20 知识水平今天学习了两个新的用法，lower_bound() 和 greater(); ForwardIterator lower_bound (ForwardIterator first, ForwardIterator last, const T&amp; val, Compare comp);123&lt;pre class=\"\"&gt;ForwardIterator upper_bound (ForwardIterator first, ForwardIterator last, const T&amp;amp; val, Compare comp); lower_bound 返回 [first, last) 之间第一个使得 Compare 函数为真的指针，如果没有这个参数，默认比较 val &lt;= elem 是否成立。 类似的，upper_bound 返回 [first, last] 之间第一个使得 Compare 函数为真的指针，如果没有这个参数，默认比较 val &lt; elem 是否成立。1234567891011121314151617181920// lower_bound/upper_bound example#include &lt;iostream&gt; // std::cout#include &lt;algorithm&gt; // std::lower_bound, std::upper_bound, std::sort#include &lt;vector&gt; // std::vectorint main () &#123; int myints[] = &#123;10,20,30,30,20,10,10,20&#125;; std::vector&lt;int&gt; v(myints,myints+8); // 10 20 30 30 20 10 10 20 std::sort (v.begin(), v.end()); // 10 10 10 20 20 20 30 30 std::vector&lt;int&gt;::iterator low,up; low=std::lower_bound (v.begin(), v.end(), 20); // ^ up= std::upper_bound (v.begin(), v.end(), 20); // ^ std::cout &lt;&amp;lt; \"lower_bound at position \" &amp;lt;&amp;lt; (low- v.begin()) &amp;lt;&amp;lt; '\\n'; //--&gt; 3 std::cout &lt;&amp;lt; \"upper_bound at position \" &amp;lt;&amp;lt; (up - v.begin()) &amp;lt;&amp;lt; '\\n'; //--&gt; 6 return 0;&#125; 上述两个函数里面最后一个参数就可以用 greater() 来代替自己写的比较函数。 翻了一下文档，greater 是一个仿函数（function object），类似的还有equal_to, not_equal_to, less, greater_equal 和 less_equal。很好用，具体原理，暂作阙疑。","categories":[],"tags":[]},{"title":"POJ 3280 Cheapest Palindrome 题解","slug":"poj-3280-cheapest-palindrome","date":"2017-03-09T03:32:36.000Z","updated":"2017-12-09T15:33:26.944Z","comments":true,"path":"2017/03/09/poj-3280-cheapest-palindrome/","link":"","permalink":"//carolunar.com/2017/03/09/poj-3280-cheapest-palindrome/","excerpt":"POJ 3280 Cheapest Palindrome 题目大意给定一个长度为 M 的字符串，由小写字母表中的前 N 个字母组成（这点很 tricky），每个字母的添加删除都有相应的代价。求通过在任意位置增删，把该字符串变为回文字符串的最小代价。 思路这道题虽然 discuss 里面都说是大水题……但由于没有接触过这种新的递推式，所以理解别人的解题报告对我来说也还是有点挑战性。 令 dp[i][j] 表示将子串 i…j 变为回文的最小代价，方程为： dp[i][j] = min(dp[i][j - 1] + cost[j位置的字符], dp[i + 1][j] + cost[i位置的字符]); 要注意的是，添加删除的本质是一样的，在某个位置添加一个字符等效于在轴对称的位置删除这个字符，因此 cost 直接取二者里面较小值。 此外 i, j 的方向也需要特别注意，i 是从末尾到开头，j 是从 i + 1 到末尾。这样可以保证每一步都用到了前一步的结果，并且循环结束后得到了将整个字符串变为回文的最小代价。","text":"POJ 3280 Cheapest Palindrome 题目大意给定一个长度为 M 的字符串，由小写字母表中的前 N 个字母组成（这点很 tricky），每个字母的添加删除都有相应的代价。求通过在任意位置增删，把该字符串变为回文字符串的最小代价。 思路这道题虽然 discuss 里面都说是大水题……但由于没有接触过这种新的递推式，所以理解别人的解题报告对我来说也还是有点挑战性。 令 dp[i][j] 表示将子串 i…j 变为回文的最小代价，方程为： dp[i][j] = min(dp[i][j - 1] + cost[j位置的字符], dp[i + 1][j] + cost[i位置的字符]); 要注意的是，添加删除的本质是一样的，在某个位置添加一个字符等效于在轴对称的位置删除这个字符，因此 cost 直接取二者里面较小值。 此外 i, j 的方向也需要特别注意，i 是从末尾到开头，j 是从 i + 1 到末尾。这样可以保证每一步都用到了前一步的结果，并且循环结束后得到了将整个字符串变为回文的最小代价。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;const int MAX_M = 2000;int N;int M;char tag[MAX_M + 3];int dp[MAX_M + 3][MAX_M + 3];int cost[26 + 3];int main() &#123; scanf(\"%d %d\", &amp;amp;N, &amp;amp;M); cin.ignore(); for (int i = 0; i &amp;lt; M; i++) &#123; scanf(\"%c\", &amp;amp;tag[i]); &#125; cin.ignore(); char tempChar; int add; int del; for (int i = 0; i &amp;lt; N; i++) &#123; scanf(\"%c %d %d\", &amp;amp;tempChar, &amp;amp;add, &amp;amp;del); cost[tempChar - 'a'] = min(add, del); cin.ignore(); &#125; for (int i = M - 1; i &amp;gt;= 0; i--) &#123; for (int j = i + 1; j &amp;lt; M; j++) &#123; if (tag[i] == tag[j]) &#123; dp[i][j] = dp[i + 1][j - 1]; &#125; else &#123; dp[i][j] = min(dp[i][j - 1] + cost[tag[j] - 'a'], dp[i + 1][j] + cost[tag[i] - 'a']); &#125; &#125; &#125; cout &amp;lt;&amp;lt; dp[0][M - 1]; return 0; &#125; &nbsp; &nbsp;","categories":[],"tags":[]},{"title":"POJ 3181 Doller Dayz 题解","slug":"poj-3181-doller-dayz","date":"2017-03-08T03:39:03.000Z","updated":"2017-12-09T15:33:26.939Z","comments":true,"path":"2017/03/08/poj-3181-doller-dayz/","link":"","permalink":"//carolunar.com/2017/03/08/poj-3181-doller-dayz/","excerpt":"POJ 3181 Doller Dayz 题目大意FJ 拿着 N 元钱去商店，发现有价格分别为 1~K 的商品无限多个。问他可以有多少种方法把钱花完。 思路非常基础的完全背包问题，内层循环顺序 + 一维数组可以解决。难点在于这题答案没有取模，非常非常大的整数。因此自己写了 Bign 的类实现加法。 【题目没有取模的话要考虑这一点，不然 WA 到死都不知道为啥……考场上可没有 discuss 看T T】","text":"POJ 3181 Doller Dayz 题目大意FJ 拿着 N 元钱去商店，发现有价格分别为 1~K 的商品无限多个。问他可以有多少种方法把钱花完。 思路非常基础的完全背包问题，内层循环顺序 + 一维数组可以解决。难点在于这题答案没有取模，非常非常大的整数。因此自己写了 Bign 的类实现加法。 【题目没有取模的话要考虑这一点，不然 WA 到死都不知道为啥……考场上可没有 discuss 看T T】 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;memory.h&gt;using namespace std;const int MAX_D = 35;class Bign &#123;public: int num[MAX_D]; Bign() &#123; memset(num, 0, sizeof(num)); &#125; void operator = (int input[MAX_D]) &#123; for (int i = 0; i &amp;lt; MAX_D; i++) &#123; num[i] = input[i]; &#125; &#125; Bign operator + (Bign &amp;amp; p) &#123; Bign res; int carry = 0; int mod = 0; for (int i = MAX_D - 1; i &amp;gt;= 0; i--) &#123; int sum = num[i] + p.num[i] + carry; mod = sum % 10; carry = sum / 10; res.num[i] = mod; &#125; return res; &#125;&#125;;const int MAX_N = 1000;const int MAX_K = 100;int N;int K;Bign dp[MAX_N + 4];void solve() &#123; dp[0].num[MAX_D - 1]= 1; for (int i = 1; i &amp;lt;= K; i++) &#123; for (int j = i; j &amp;lt;= N; j++) &#123; dp[j] = dp[j] + dp[j - i]; &#125; &#125; int s; for (int i = 0; i &amp;lt; MAX_D; i++) &#123; if (dp[N].num[i]) &#123; s = i; break; &#125; &#125; for (int i = s; i &amp;lt; MAX_D; i++) &#123; cout &amp;lt;&amp;lt; dp[N].num[i]; &#125;&#125;int main() &#123; cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; K; solve(); return 0;&#125; &nbsp;","categories":[],"tags":[]},{"title":"POJ 3046 Ant Counting 题解","slug":"poj-3046-ant-counting","date":"2017-03-08T03:32:37.000Z","updated":"2017-12-09T15:33:26.971Z","comments":true,"path":"2017/03/08/poj-3046-ant-counting/","link":"","permalink":"//carolunar.com/2017/03/08/poj-3046-ant-counting/","excerpt":"POJ 3046 Ant Counting 题目大意有 T 种类型的蚂蚁，每种的数量各异，一共 A 只。不同类型的蚂蚁可以区分而同种的不可以。问用这些蚂蚁组成数量为 S~B 之间的小队，一共有多少种组合方法。比如 S 为 2，B为3，分别计算组成 2 人队和 3 人队有多少种组合方法，相加就是答案。 思路多重背包求方案总数问题。 在这道题里面学到了二维滚动数组，把 dp[MAX_T][MAX_A] 压缩成为 dp[2][MAX_A]. 用与 1 运算 &amp; 来区分当前和前一个数组。","text":"POJ 3046 Ant Counting 题目大意有 T 种类型的蚂蚁，每种的数量各异，一共 A 只。不同类型的蚂蚁可以区分而同种的不可以。问用这些蚂蚁组成数量为 S~B 之间的小队，一共有多少种组合方法。比如 S 为 2，B为3，分别计算组成 2 人队和 3 人队有多少种组合方法，相加就是答案。 思路多重背包求方案总数问题。 在这道题里面学到了二维滚动数组，把 dp[MAX_T][MAX_A] 压缩成为 dp[2][MAX_A]. 用与 1 运算 &amp; 来区分当前和前一个数组。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;memory.h&gt;#include &lt;stdio.h&gt;using namespace std;const int MAX_T = 1000;const int MAX_A = 100000;const int MOD = 1000000;int T;int A;int S;int B;int c[MAX_T + 3];int dp[2][MAX_A + 3];int main() &#123; scanf(\"%d %d %d %d\", &amp;amp;T, &amp;amp;A, &amp;amp;S, &amp;amp;B); int ant; for (int i = 0; i &amp;lt; A; i++) &#123; scanf(\"%d\", &amp;amp;ant); c[ant]++; &#125; dp[0][0] = 1; for (int i = 1; i &amp;lt;= T; i++) &#123; int cur = i &amp;amp; 0x1; int pre = (i - 1) &amp;amp; 0x1; memset(dp[cur], 0, sizeof(dp[cur])); for (int j = 0; j &amp;lt;= A; j++) &#123; for (int k = 0; k &amp;lt;= min(c[i], j); k++) &#123; dp[cur][j] = (dp[cur][j] + dp[pre][j - k]) % MOD; &#125; &#125; &#125; int res = 0; for (int i = S; i &amp;lt;= B; i++) &#123; res += dp[T&amp;amp; 0x1][i] % MOD; &#125; cout &amp;lt;&amp;lt; res % MOD; return 0; &#125; &nbsp;","categories":[],"tags":[]},{"title":"POJ 1742 Coins 题解","slug":"poj-1742-coins","date":"2017-03-08T02:53:08.000Z","updated":"2017-12-09T15:33:26.983Z","comments":true,"path":"2017/03/08/poj-1742-coins/","link":"","permalink":"//carolunar.com/2017/03/08/poj-1742-coins/","excerpt":"POJ 1742 Coins 题目大意n 种硬币，面值和数量各异。能拼成 1~m 中的多少个值。 思路书上例题多重部分和问题的稍微复杂版。 用 DP 求取 bool 结果的话会有不少浪费。 因此这里用 dp[i + 1][j] := 用前 i 种数加和得到 j 时第 i 种数最多能剩余多少个（不能加和得到 j 的情况下为 -1）。 只要看最终是否满足 dp[n][m] 是否大于等于 0 ，就得到答案。","text":"POJ 1742 Coins 题目大意n 种硬币，面值和数量各异。能拼成 1~m 中的多少个值。 思路书上例题多重部分和问题的稍微复杂版。 用 DP 求取 bool 结果的话会有不少浪费。 因此这里用 dp[i + 1][j] := 用前 i 种数加和得到 j 时第 i 种数最多能剩余多少个（不能加和得到 j 的情况下为 -1）。 只要看最终是否满足 dp[n][m] 是否大于等于 0 ，就得到答案。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;memory.h&gt;using namespace std;const int MAX_N = 100;const int MAX_M = 100000;int n;int m;int a[MAX_N + 3];int c[MAX_N + 3];int dp[MAX_M + 3];void solve() &#123; memset(dp, -1, sizeof(dp)); dp[0] = 0; for (int i = 1; i &amp;lt;= n; i++) &#123; for (int j = 0; j &amp;lt;= m; j++) &#123; if (dp[j] &amp;gt;= 0) &#123; //前 i - 1 个数已经能够加和组成 j, 所以第 i 个数全部剩下 dp[j] = c[i]; &#125; else if (j &amp;lt; a[i] || dp[j - a[i]] &amp;lt;= 0) &#123; //加上这个数也不能组成 j dp[j] = -1; &#125; else &#123; dp[j] = dp[j - a[i]] - 1; &#125; &#125; &#125; int count = 0; for (int i = 1; i &amp;lt;= m; i++) &#123; if(dp[i] &amp;gt;= 0) &#123; count++; &#125; &#125; cout &amp;lt;&amp;lt; count &amp;lt;&amp;lt; endl;&#125;int main() &#123; while(scanf(\"%d %d\", &amp;amp;n, &amp;amp;m) &amp;amp;&amp;amp; n) &#123; for (int i = 1; i &amp;lt;= n; i++) &#123; scanf(\"%d\", &amp;amp;a[i]); &#125; for (int i = 1; i &amp;lt;= n; i++) &#123; scanf(\"%d\", &amp;amp;c[i]); &#125; solve(); &#125; return 0; &#125; &nbsp;","categories":[],"tags":[]},{"title":"POJ 3616 Milking Time 题解","slug":"poj-3616-milking-time","date":"2017-03-03T08:29:39.000Z","updated":"2017-12-09T15:33:26.981Z","comments":true,"path":"2017/03/03/poj-3616-milking-time/","link":"","permalink":"//carolunar.com/2017/03/03/poj-3616-milking-time/","excerpt":"POJ 3616 Milking Time 思路对区间排序。令 dp[i] 表示到第 i 个区间时，取到的牛奶的最大值。dp[i] 为当前效率 + 之前所有能与之兼容的区间里取奶的最大值。","text":"POJ 3616 Milking Time 思路对区间排序。令 dp[i] 表示到第 i 个区间时，取到的牛奶的最大值。dp[i] 为当前效率 + 之前所有能与之兼容的区间里取奶的最大值。 代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;const int MAX_M = 1000;int N;int M;int R;struct Invl &#123; int s; int t; int eff; bool operator &amp;lt; (Invl &amp;amp; i) &#123; return s &amp;lt; i.s; &#125;&#125;;Invl invl[MAX_M + 3];int dp[MAX_M + 3];int main() &#123; scanf(\"%d %d %d\", &amp;amp;N, &amp;amp;M, &amp;amp;R); for (int i = 1; i &amp;lt;= M; i++) &#123; scanf(\"%d %d %d\", &amp;amp;invl[i].s, &amp;amp;invl[i].t, &amp;amp;invl[i].eff); &#125; sort(invl + 1, invl + 1 + M); for (int i = 1; i &amp;lt;= M; i++) &#123; dp[i] = invl[i].eff; for (int j = 1; j &amp;lt;= i; j++) &#123; if (invl[j].t + R &amp;lt;= invl[i].s) &#123; dp[i] = max(dp[i], dp[j] + invl[i].eff); &#125; &#125; &#125; cout &amp;lt;&amp;lt; *max_element(dp + 1, dp + 1 + M); return 0;&#125; 反思刚开始用了 01 背包的思路，用 dp[i][j] 表示前 i 个区间直到 j 时刻取奶得到的最大值。有 O(N * M) 的复杂度所以 TLE 了(:зゝ∠) 保存一下代码……12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;const int MAX_N = 1000000;const int MAX_M = 1000;int N;int M;int R;long long dp[MAX_N + 3];pair&lt;pair&amp;lt;int, int&amp;gt;, int&gt; invl[MAX_M + 3];int main() &#123; scanf(\"%d %d %d\", &amp;amp;N, &amp;amp;M, &amp;amp;R); for (int i = 1; i &amp;lt;= M; i++) &#123; scanf(\"%d %d %d\", &amp;amp;invl[i].first.first, &amp;amp;invl[i].first.second, &amp;amp;invl[i].second); &#125; sort(invl + 1, invl + 1 + M); for (int i = 1; i &amp;lt;= M; i++) &#123; for (int j = N; j &amp;gt;= invl[i].first.second; j--) &#123; dp[j] = max(dp[j], dp[(invl[i].first.first - R) * (invl[i].first.first - R &amp;gt; 0)] + invl[i].second); &#125; &#125; cout &amp;lt;&amp;lt; dp[N]; return 0;&#125; 这两种思路看似只有内层循环不一样，实际上最大的区别在于 dp 的对象不同。第一种在于第 i 个区间，而第二种在于第 i 个时刻。第一种的 dp[i] 表示的数值一定取了当前区间内的牛奶，而第二种的 dp[i][j] 只是表示算到这儿了，不一定取了这个。也是由于这个原因，第一种最后要输出 dp 数组中的最大值，而第二种输出 dp 数组最末的一个值。 extra*max_element(first, last) 函数，和 sort() 函数类似，取 [first, last) 区间内的最大值，在 里面，不用自己写循环了。","categories":[],"tags":[]},{"title":"POJ 2385 Apple Catching 题解","slug":"poj-2385-apple-catching","date":"2017-03-02T08:13:44.000Z","updated":"2017-12-09T15:31:04.312Z","comments":true,"path":"2017/03/02/poj-2385-apple-catching/","link":"","permalink":"//carolunar.com/2017/03/02/poj-2385-apple-catching/","excerpt":"","text":"POJ 2385 Apple Catching 注意奶牛刚开始站在 #1 树下；步数不要求必须用完。 思路令 dp[i][j] 表示 前 i 秒用完 j 步时，最多可以接到的苹果的个数。 状态转移方程为：dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1]) + (a[i] == j % 2 + 1), 其中 a[i] 是输入的数组。 方程解释：“前 i 秒用完 j 步”这个子问题，若第 i 秒站在原地未动，说明“前 i - 1 秒用完了 j 步”，即为 dp[i - 1][j]；若第 i 秒时刚从另一棵树下移动过来，说明“前 i - 1 秒用完了 j - 1 步”，即为 dp[i - 1][j - 1]。两者之间取更大值，便得到前 i - 1 秒接到的苹果的最大值 T = max(dp[i - 1][j], dp[i - 1][j - 1])。再看第 i 秒可否接到苹果。因为设定是用完 j 步，即无论如何奶牛都移动了 j 次，所以这时 j 的奇偶性就可以说明奶牛站在#1， #2 哪棵树下，再判断此时这棵树会不会落下苹果（ a[i] 的值为 1 或 2），就可以决定 T 是否要加 1，便得到 dp[i][j]。 需要注意的是，在循环结束后，dp[T][W] 并不一定是前 T 秒接到苹果的最大值，因为限定了步数用完，所以用完步数反而可能导致接到的苹果变少，如下组数据： 输入 1 1 1 输出 0因为必须用完 1 步，所以奶牛在 1 秒时会移到 #2 树下，没接到这个苹果，dp[1][1] 为 0，而正确输出应该为 1，即没有动的时候 dp[1][0]。 因此最后应输出 dp[T][0] ~ dp[T][W] 中的最大值。 &nbsp; AC代码12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;math.h&gt;using namespace std;const int MAX_T = 1000;const int MAX_W = 30;int n;int T;int W;int dp[MAX_T + 3][MAX_W + 3];int apple[MAX_T + 3];int main() &#123; cin &amp;gt;&amp;gt; T &amp;gt;&amp;gt; W; for (int i = 1; i &amp;lt;= T; i++) &#123; scanf(\"%d\", &amp;amp;apple[i]); dp[i][0] = dp[i - 1][0] + (apple[i] == 1); for (int j = 1; j &amp;lt;= W; j++) &#123; dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1]) + (apple[i] == j % 2 + 1); &#125; &#125; int maxA = 0; for (int i = 0; i &amp;lt;= W; i++) &#123; maxA = max(maxA, dp[T][i]); &#125; cout &amp;lt;&amp;lt; maxA; return 0;&#125; &nbsp;","categories":[],"tags":[]},{"title":"POJ 2229 Sumsets 题解","slug":"poj-2229-sumsets","date":"2017-02-22T05:27:59.000Z","updated":"2017-12-09T15:31:04.307Z","comments":true,"path":"2017/02/22/poj-2229-sumsets/","link":"","permalink":"//carolunar.com/2017/02/22/poj-2229-sumsets/","excerpt":"","text":"POJ 2229 Sumsets 思路： 两种方法。 方法一：根据题目特定的条件找出规律，用小于n的2的幂组成n，令 dp[i] 表示方案总数，有下面两种情况： i为奇数，dp[i] = dp[i - 1] i为偶数，有两种可能，一种是组成 i 的数字里面没有 1, 即全是偶数，此时方案数为 dp[i / 2], 另一种可能是有 1, 那么必须有两个1，剩下的就是 dp[i - 2]. 故 dp[i] = dp[i - 1] + dp[i&gt;&gt;1]123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;math.h&gt;using namespace std;const int MAX_N = 1000000;const int MOD = 1000000000;int n;int dp[MAX_N + 3];int main() &#123; cin &amp;gt;&amp;gt; n; dp[0] = 1; dp[1] = 1; for (int j = 2; j &amp;lt;= n; j++) &#123; if (j &amp;amp; 1) &#123; dp[j] = dp[j - 1] % MOD; &#125; else &#123; dp[j] = (dp[j - 2] + dp[j &amp;gt;&amp;gt; 1]) % MOD; &#125; &#125; cout &amp;lt;&amp;lt; dp[n]; return 0;&#125; &nbsp; 方法二：看成完全背包问题，令 dp[i][j] 表示前 i 个数字组成 j 的方案数。 由求最大价值变成求方案总数。方程里面的 min 改成 sum。 这里重复利用 dp 数组，因此可简化成一维数组。1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;math.h&gt;using namespace std;const int MAX_N = 1000000;int n;int number[20];int dp[MAX_N + 3];int main() &#123; for (int i = 0; i &amp;lt; 20; i++) &#123; number[i] = 1 &amp;lt;&amp;lt; i; &#125; cin &amp;gt;&amp;gt; n; int m = log((float)n) / log(2.0); dp[0] = 1; for (int i = 0; i &amp;lt;= m; i++) &#123; for (int j = number[i]; j &amp;lt;= n; j++) &#123; dp[j] = (dp[j] + dp[j - number[i]]) % 1000000000; &#125; &#125; cout &amp;lt;&amp;lt; dp[n]; return 0;&#125; 总结：第一种方法更有技巧性，只有一层循环。充分利用了题目的数据特点（都是 2 的幂），但是只适用于这一种情况。 第二种方法更通用，没有考虑数据特点，因此也适用于其他的没有特定规律的数据，比如1, 2, 5, 10… &nbsp;","categories":[],"tags":[]},{"title":"背包问题 HDU 2602 Bone Collector + HDU 1114 Piggy-Bank","slug":"pack-problem","date":"2017-02-19T14:29:15.000Z","updated":"2017-12-09T15:31:04.407Z","comments":true,"path":"2017/02/19/pack-problem/","link":"","permalink":"//carolunar.com/2017/02/19/pack-problem/","excerpt":"","text":"HDU 2602 Bone Collector 最简单的01背包问题123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;memory.h&gt;using namespace std;const int MAX_N = 1000;int N;int V;int value[MAX_N + 1];int vol[MAX_N + 1];long long dp[MAX_N + 1];int main() &#123; int input; cin &amp;gt;&amp;gt; input; while(input-- &amp;gt; 0) &#123; cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; V; for (int i = 0; i &amp;lt; N; i++) &#123; scanf(&quot;%d&quot;, &amp;amp;value[i]); &#125; for (int i = 0; i &amp;lt; N; i++) &#123; scanf(&quot;%d&quot;, &amp;amp;vol[i]); &#125; for (int i = 0; i &amp;lt; N; i++) &#123; for (int j = V; j &amp;gt;= vol[i]; j--) &#123; dp[j] = max(dp[j], dp[j - vol[i]] + value[i]); &#125; &#125; printf(&quot;%lld\\n&quot;, dp[V]); memset(dp, 0, sizeof(dp)); &#125; return 0;&#125; HDU 1114 Piggy-Bank 完全背包：包中的每个物品有无限多个123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;memory.h&gt;using namespace std;const int MAX_N = 500;const int MAX_E = 10000;const int INF = 0x3f3f3f3f;int T;int E;int F;int N;pair&lt;int, int&gt; coin[MAX_N + 3];int dp[MAX_E + 3];int main() &#123; scanf(\"%d\", &amp;amp;T); while(T--) &#123; scanf(\"%d %d\", &amp;amp;E, &amp;amp;F); scanf(\"%d\", &amp;amp;N); for (int i = 0; i &amp;lt; N; i++) &#123; scanf(\"%d %d\", &amp;amp;coin[i].first, &amp;amp;coin[i].second); &#125; E = F - E; memset(dp, INF, sizeof(dp)); dp[0] = 0; for (int i = 0; i &amp;lt; N; i++) &#123; for (int j = coin[i].second; j &amp;lt;= E; j++) &#123; dp[j] = min(dp[j], dp[j - coin[i].second] + coin[i].first); &#125; &#125; if (dp[E] != INF) &#123; printf(\"The minimum amount of money in the piggy-bank is %d.\\n\", dp[E]); &#125; else &#123; printf(\"This is impossible.\\n\"); &#125; &#125; return 0;&#125; &nbsp; &nbsp; 我们看到的求最优解的背包问题题目中，事实上有两种不太相同的问法。有的题目要求“恰好装满背包”时的最优解，有的题目则并没有要求必须把背包装满。一种区别这两种问法的实现方法是在初始化的时候有所不同。 如果是第一种问法，要求恰好装满背包，那么在初始化时除了F[0]为0，其 它F[1..V ]均设为−∞，这样就可以保证最终得到的F[V ]是一种恰好装满背包的最优解。 如果并没有要求必须把背包装满，而是只希望价格尽量大，初始化时应该将F[0..V ]全部设为0。 这是为什么呢？可以这样理解：初始化的F数组事实上就是在没有任何物品可以放入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量 为0的背包可以在什么也不装且价值为0的情况下被“恰好装满”，其它容量的背包均没有合法的解，属于未定义的状态，应该被赋值为-∞了。如果背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为0，所以初始时状态的值也就全部为0了。 ——背包九讲开始不太理解这段话，自己用纸笔画表推了一遍就懂了。一定不能怕麻烦。 常见的背包要求得到最大的价值，而像上面的 HDU1114 这道题求的是最小的价值。针对这种要求，除了把 max 换成 min 之外，dp 数组初始化也不再用 −∞，而是用 +∞。 HDU 2192 512 多重背包，即每个物品的数量有限。 测试好多数据都对，一直 WA，没有找到原因，暂作阙疑吧……12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;memory.h&gt;const int MAX_N = 100;int C;int n;int m;int p;int h;int c;long long dp[MAX_N + 5];using namespace std;int main() &#123; scanf(&quot;%d&quot;, &amp;amp;C); while(C--) &#123; memset(dp, 0, sizeof(dp)); scanf(&quot;%d %d&quot;, &amp;amp;n, &amp;amp;m); for (int i = 0; i &amp;lt; m; i++) &#123; scanf(&quot;%d %d %d&quot;, &amp;amp;p, &amp;amp;h, &amp;amp;c); if (p * c &amp;gt;= n) &#123; for (int j = p; j &amp;lt;= n; j++) &#123; dp[j] = max(dp[j], dp[j - p] + h); &#125; &#125; else &#123; int k = 1; while (k &amp;lt; c) &#123; for (int j = n; j &amp;gt;= p; j--) &#123; dp[j] = max(dp[j], dp[j - k * p] + k * h); &#125; c -= k; k *= 2; &#125; for (int j = n; j &amp;gt;= p; j--) &#123; dp[j] = max(dp[j], dp[j - c * p] + c * h); &#125; &#125; &#125; cout &amp;lt;&amp;lt; dp[n] &amp;lt;&amp;lt; endl; &#125; return 0;&#125; 要点： 01背包，节省空间用一维数组的话，关键在于逆序。 完全背包，用一维数组，关键在于正序。 多重背包简化成 01 背包和完全背包。 &nbsp; 代码中可以简化的地方： 每个物品的重量、价值、数量这三个变量其实都可以在每个最外层循环中重复利用，不必设置多个数组，这样好写也好记。 &nbsp; &nbsp; reference 背包问题九讲","categories":[],"tags":[]},{"title":"POJ 3176 Cow Bowling 题解","slug":"poj-3176-cow-bowling","date":"2017-02-13T15:35:13.000Z","updated":"2017-12-09T15:31:04.339Z","comments":true,"path":"2017/02/13/poj-3176-cow-bowling/","link":"","permalink":"//carolunar.com/2017/02/13/poj-3176-cow-bowling/","excerpt":"","text":"POJ 3176 Cow Bowling 思路： 用 dp[i][j] 表示，从最顶端到第 [i, j] 个位置的最长路径（用每个点的数字衡量）。 这样可以正向推导。最终得出最后一排每个位置的最长路径，取最大值输出。12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;const int MAX_N = 350;int n;int tri[MAX_N + 3][MAX_N + 3];int dp[MAX_N + 3][MAX_N + 3];void solve() &#123; int res = 0; for (int i = 1; i &amp;lt;= n; i++) &#123; for (int j = 1; j &amp;lt;= i; j++) &#123; dp[i][j] = tri[i][j] + max(dp[i - 1][j - 1], dp[i - 1][j]); &#125; &#125; for (int i = 1; i &amp;lt;= n; i++) &#123; res = max(res, dp[n][i]); &#125; printf(\"%d\", res);&#125;int main() &#123; scanf(\"%d\", &amp;amp;n); for (int i = 1; i &amp;lt;= n; i++) &#123; for (int j = 1; j &amp;lt;= i; j++) &#123; scanf(\"%d\", &amp;amp;tri[i][j]); &#125; &#125; solve(); return 0;&#125; &nbsp;","categories":[],"tags":[]},{"title":"POJ 3262 Protecting the Flowers 题解","slug":"poj-3262-protecting-the-flowers","date":"2017-02-12T14:25:16.000Z","updated":"2017-12-09T15:31:04.373Z","comments":true,"path":"2017/02/12/poj-3262-protecting-the-flowers/","link":"","permalink":"//carolunar.com/2017/02/12/poj-3262-protecting-the-flowers/","excerpt":"","text":"&nbsp; POJ 3262 Protecting the Flowers 奶牛吃花花 这道题，需要好好总结。 原来的思路是，依次计算出送走奶牛1~N会毁掉的花的数量，找出最小的，送走这头牛。然后又在剩下的奶牛中找可以使毁掉的花的数量最小的送走。如此循环直到全被送走。 对是对，只是也太繁琐了些，并且超时。 没有意识到其实这样的思路进行了很多次重复的比较。 &nbsp; 后来看了别人的思路，发现可以先排序，一次就可以排好奶牛应该被送走的顺序。 刚开始觉得，这样很像之前做的Yogurt Factory题目，用动态规划记录每相邻两个牛的比较结果。 写完后发现不对，才发现又陷入了一个误区：动态规划适合于，前面的结果会影响后面的结果，但后面的不会影响前面的结果，的情况。 比如酸奶厂那道题，以后的星期可以用前一个星期生产的成本更低的酸奶，但之前的星期是不可用以后生产的，也就是说是局部比较，并不是统一的排序。 而这道题，需要统一的排序，因此只比较相邻两个是不行的。 &nbsp; 刚开始想到了排序，但没有想到好的排序思路，觉得时长也不能作为依据，吃花数量也不能作为依据，没有想到这两个可以通过运算组成新的依据。123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;int n;struct Cow &#123; int first; int second; bool operator &amp;lt; (const Cow &amp;amp; c) &#123; return first * c.second &amp;lt; second * c.first; &#125;&#125;; Cow cow[100000];typedef long long ll;int main() &#123; scanf(\"%d\", &amp;amp;n); ll sum = 0; ll res = 0; for (int i = 0; i &amp;lt; n; i++) &#123; scanf(\"%d %d\", &amp;amp;cow[i].first, &amp;amp;cow[i].second); sum += cow[i].second; //sum记录所有奶牛吃花的总速度 &#125; sort(cow, cow + n); for (int i = 0; i &amp;lt; n - 1; i++) &#123; sum -= cow[i].second; //每送走一头牛，吃花总速度就减去这头牛的速度 res += 2 * sum * cow[i].first; &#125; cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; endl; return 0;&#125; &nbsp;","categories":[],"tags":[]},{"title":"POJ 1862 Stripies 题解","slug":"poj-1862-stripies","date":"2017-02-12T14:22:27.000Z","updated":"2017-12-09T15:31:04.419Z","comments":true,"path":"2017/02/12/poj-1862-stripies/","link":"","permalink":"//carolunar.com/2017/02/12/poj-1862-stripies/","excerpt":"","text":"POJ 1862 Stripies 思路： 贪心策略为每次挑选最大的两个数，进行2*sqrt(a,b)运算后放回到数组中。有点类似于之前做的Fence Repair题目。 这样可以保证大数被开方的次数更多，最后的结果更小。 注意： n为1的情况，WA了几次。 学会C++输出格式控制: http://c.biancheng.net/cpp/biancheng/view/2227.html。12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;iomanip&gt;#include &lt;algorithm&gt;using namespace std;int n;double w[103];int main() &#123; double res = 0; scanf(\"%d\", &amp;amp;n); for (int i = 0; i &amp;lt; n; i++) &#123; scanf(\"%lf\", &amp;amp;w[i]); &#125; while (n &amp;gt; 0) &#123; if (n == 1) &#123; res = w[0]; break; &#125; sort(w, w + n); double newW = 2 * sqrt(w[n - 1] * w[n - 2]); res = newW; w[n - 2] = newW; n--; &#125; cout &amp;lt;&amp;lt; setiosflags(ios::fixed) &amp;lt;&amp;lt; setprecision(3) &amp;lt;&amp;lt; res &amp;lt;&amp;lt; endl; return 0;&#125; //这种玄幻的题目读起来有一种读哈利波特的感觉……","categories":[],"tags":[]},{"title":"POJ 3040 Allowance 题解","slug":"poj-3040-allowance","date":"2017-02-12T14:18:48.000Z","updated":"2017-12-09T15:31:04.355Z","comments":true,"path":"2017/02/12/poj-3040-allowance/","link":"","permalink":"//carolunar.com/2017/02/12/poj-3040-allowance/","excerpt":"","text":"POJ 3040 Allowance 题意： 农夫要给奶牛Bessie每周津贴。农夫有N种不同面额不同数量的硬币，而且相邻大小的硬币面额存在整除关系（1分、5分、10分、50分）。他每周至少要给奶牛C分钱，计算他所有的钱最多可以给奶牛多少周。 思路： 有限的钱要维持尽量多的时间，关键在于每周尽可能少的超过最低标准。因此，对所有的硬币分两类，面额大于C的硬币一天给一个。面额小于C的硬币……没有想到合适的贪心策略了。 参考了：码农场 » POJ 3040 Allowance 题解 《挑战程序设计竞赛(第2版)》 大硬币面额是小硬币面额的倍数很重要，这意味着同等数量的一堆小硬币可以被一枚大硬币代替，这样小硬币就可以剩下来以后用，可以保证最小的浪费，所以 1. 从大到小贪心，尽量多的选择大硬币，但是不要超过所需金额c 2. 从小到大贪心。 1、2都执行完之后，如果所需的金额还是大于0，就说明硬币不够再多给一周了，break。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;math.h&gt;using namespace std;int n;int m = 0; //需要进行贪心的硬币 int c;pair&lt;int, int&gt; coin[20];int solve() &#123; int res = 0; sort(coin, coin + m); int need = c; while (1) &#123; for (int i = m - 1; i &amp;gt;= 0; --i) &#123; if (need &amp;gt; 0 &amp;amp;&amp;amp; coin[i].second &amp;gt; 0) &#123; int t = min(coin[i].second, need / coin[i].first); need -= t * coin[i].first; coin[i].second -= t; &#125; &#125; for (int i = 0; i &amp;lt; m; i++) &#123; if (need &amp;gt; 0 &amp;amp;&amp;amp; coin[i].second &amp;gt; 0) &#123; int t = min(coin[i].second, (int)ceil((double)need / (double)(coin[i].first))); need -= t * coin[i].first; coin[i].second -= t; &#125; &#125; if (need &amp;gt; 0) &#123; break; &#125; res++; need = c; &#125; return res;&#125;int main() &#123; int res = 0; int v; int b; scanf(\"%d %d\", &amp;amp;n, &amp;amp;c); for (int i = 0; i &amp;lt; n; ++i) &#123; scanf(\"%d %d\", &amp;amp;v, &amp;amp;b); if (v &amp;gt;= c) &#123; res += b; &#125; else &#123; coin[m].first = v; coin[m].second = b; m++; &#125; &#125; res += solve(); printf(\"%d\\n\", res); return 0;&#125; &nbsp;","categories":[],"tags":[]},{"title":"POJ 2393 Yogurt factory 题解","slug":"poj-2393-yogurt-factory","date":"2017-02-12T14:17:15.000Z","updated":"2017-12-09T15:31:04.319Z","comments":true,"path":"2017/02/12/poj-2393-yogurt-factory/","link":"","permalink":"//carolunar.com/2017/02/12/poj-2393-yogurt-factory/","excerpt":"","text":"POJ 2393 Yogurt factory 题目很简单，有一些需要注意的地方。 刚开始没有定义成long long的变量导致WA。 O(n2)的复杂度导致TLE。 学习@Lorazepam ，用了动态规划。 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;int n;int s;ll c[10005];ll y[10005];void solve() &#123; ll res = 0; for (int i = 1; i &amp;lt; n; i++) &#123; c[i] = min(c[i], c[i - 1] + s); //每一周只需要和上周比较的原因是上周和上上周也比较过了。 &#125; for (int i = 0; i &amp;lt; n; i++) &#123; res += c[i] * y[i]; &#125; printf(\"%lld\\n\", res);&#125;int main() &#123; scanf(\"%d %d\", &amp;amp;n, &amp;amp;s); for (int i = 0; i &amp;lt; n; i++) &#123; scanf(\"%d %d\", &amp;amp;c[i], &amp;amp;y[i]); &#125; solve(); return 0;&#125; &nbsp;","categories":[],"tags":[]},{"title":"POJ 3190 Stall Reservations 题解","slug":"poj-3190-stall-reservations","date":"2017-02-12T14:15:34.000Z","updated":"2017-12-09T15:31:04.348Z","comments":true,"path":"2017/02/12/poj-3190-stall-reservations/","link":"","permalink":"//carolunar.com/2017/02/12/poj-3190-stall-reservations/","excerpt":"","text":"POJ 3190 Stall Reservations 思路： 优先选择进食最早的奶牛，晚来的奶牛如果进食时间和前一只奶牛重叠，就放到一个新栏里，否则的话就放在当前栏里。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;stdio.h&gt;using namespace std;int n;struct cow &#123; int first; int second; int index; bool operator &amp;lt; (const cow &amp;amp;c) &#123; return first &amp;lt; c.first; &#125;&#125;;cow invl[50000];pair&lt;int, int&gt; stall[50001];int assigned[50000];void solve() &#123; int res = 1; sort(invl, invl + n); for (int i = 0; i &amp;lt; n; i++) &#123; bool hasFound = 0; int s = invl[i].first; int t = invl[i].second; int cowIndex = invl[i].index; for (int j = 1; j &amp;lt;= res; j++) &#123; if (s &amp;gt; stall[j].second) &#123; stall[j].second = t; hasFound = 1; assigned[cowIndex] = j; break; &#125; &#125; if (hasFound == 0) &#123; res++; stall[res].first = s; stall[res].second = t; assigned[cowIndex] = res; &#125; &#125; printf(\"%d\\n\", res); for (int i = 0; i &amp;lt; n; i++) &#123; printf(\"%d\\n\", assigned[i]); &#125; &#125;int main() &#123; cin &amp;gt;&amp;gt; n; for (int i = 0; i &amp;lt; n; i++) &#123; scanf(\"%d\", &amp;amp;invl[i].first); scanf(\"%d\", &amp;amp;invl[i].second); invl[i].index = i; &#125; solve(); return 0;&#125; &nbsp;","categories":[],"tags":[]},{"title":"POJ 1328 Radar Installation 题解","slug":"poj-1328-radar-installation","date":"2017-02-12T14:14:01.000Z","updated":"2017-12-09T15:31:04.375Z","comments":true,"path":"2017/02/12/poj-1328-radar-installation/","link":"","permalink":"//carolunar.com/2017/02/12/poj-1328-radar-installation/","excerpt":"","text":"POJ 1328 Radar Installation 第一次的思路：所有岛屿按x坐标排序，从最左开始，画圆心在x轴上的圆，使得该岛屿在圆的边上，也就是选择圆心尽量靠右的圆。再从第一个没有被该圆覆盖的岛屿开始上述过程。 错误，因为岛屿还有y坐标的影响，会出现这种情况：岛屿i被一个圆覆盖了，但是岛屿i-1位置更高，没有被覆盖。 &nbsp; 正确策略：以岛屿为圆心做圆，与x轴所成的弦，就是可以覆盖这个岛屿的雷达的区间。将所有区间去重。 区间去重的时候要注意：是否会影响当前用来作比较的数，比如例题POJ3069就不会，而这道题会，雷达的位置是变化的，要处在所有区间的交集内： &nbsp; 28 rx = min(rx, r[i].second);12 #include #include #include using namespace std; int n;int d;pair p[1000];pair r[1000]; double getDx(int py) { return (double)sqrt((double)(d d - py py));} int solve() { int res = 0; for (int i = 0; i &lt; n; i++) { r[i].first = p[i].first - getDx(p[i].second); r[i].second = p[i].first + getDx(p[i].second); } sort(r, r + n); int i = 0; while (i &lt; n) { double rx = r[i].second; i++; while (i &lt; n &amp;&amp; (double)(r[i].first) &lt;= rx) { rx = min(rx, r[i].second); i++; } res++; } return res;} int main() { int caseNO = 0; while(cin &gt;&gt; n &gt;&gt; d &amp;&amp; n!= 0) { caseNO++; int solvable = 1; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; p[i].first; cin &gt;&gt; p[i].second; if (p[i].second &gt; d) { solvable = 0; } } if (solvable) { cout &lt;&lt; “Case “ &lt;&lt; caseNO &lt;&lt; “: “ &lt;&lt; solve() &lt;&lt; endl; } else { cout &lt;&lt; “Case “ &lt;&lt; caseNO &lt;&lt; “: -1” &lt;&lt; endl; } } return 0;}``` &nbsp;","categories":[],"tags":[]},{"title":"POJ 2376 Cleaning Shifts 题解","slug":"poj-2376-cleaning-shifts","date":"2017-02-12T14:11:12.000Z","updated":"2017-12-09T15:31:04.417Z","comments":true,"path":"2017/02/12/poj-2376-cleaning-shifts/","link":"","permalink":"//carolunar.com/2017/02/12/poj-2376-cleaning-shifts/","excerpt":"","text":"POJ 2376 Cleaning Shifts 思路： 所有可工作的区间左端点进行排序，如果没有从1开始的，直接输出-1； 否则，从最早的区间开始，寻找左端点在这个区间之内，同时右端点大于这个区间右端点的区间，如果找不到，说明中间断掉，也输出-1； 中间没有断掉的话，就不断循环上述过程，直到当前工作结束时间大于shifts的最大值。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;stdio.h&gt;using namespace std;int n;int t;pair&lt;int, int&gt; invl[25000];void solve() &#123; sort(invl, invl + n); int res = 0; int cur = 0; while (cur &amp;lt; t) &#123; int maxT = 0; int count = 0; for (int i = 0; i &amp;lt; n; i++) &#123; if (invl[i].first &lt;= cur + 1 &amp;amp;&amp;amp; invl[i].second &gt; cur) &#123; count++; maxT = max(maxT, invl[i].second); &#125; &#125; if (count == 0) &#123; printf(\"-1\"); return; &#125; cur = maxT; res++; &#125; printf(\"%d\", res);&#125;int main() &#123; scanf(\"%d %d\", &amp;amp;n, &amp;amp;t); int maxT = 0; for (int i = 0; i &amp;lt; n; i++) &#123; scanf(\"%d %d\", &amp;amp;invl[i].first, &amp;amp;invl[i].second); maxT = max(maxT, invl[i].second); &#125; if (maxT &amp;lt; t) &#123; printf(\"-1\"); &#125; else &#123; solve(); &#125; return 0; &#125; &nbsp;","categories":[],"tags":[]},{"title":"POJ 3253 Fence Repair 题解","slug":"poj-3253-fence-repair","date":"2017-02-12T14:09:03.000Z","updated":"2017-12-09T15:31:04.422Z","comments":true,"path":"2017/02/12/poj-3253-fence-repair/","link":"","permalink":"//carolunar.com/2017/02/12/poj-3253-fence-repair/","excerpt":"","text":"POJ 3253 Fence Repair 书中例题。 在看题解之前自己做了一下，用了错误的贪心策略：“越短的木棒切割的时间应该越晚”，局部来看是对的。 正确策略的局部也是这样的。 不过自己的想法不够全面，只想到了第一步。 例如需要1,2,3,4,5 五根木棒，我觉得应该： 先花15的代价切下来长度为5的， 再花10的代价切下来长度为4的， 再花6的代价切下来长度为3的， 最后花3的代价切下来长度为2的， 剩下的也就是长度为1的。 这样代价一共是15+10+6+3=34，## 而最优策略代价为33. 因此， 虽然说越长的木棒应该最先被切没错，但是对于选择最长木棒这件事，并不是直接从题目所需要的所有长度的木棒里面选最长的，而是：## 两根次长的也许可以拼成一根比当前最长更长的。 因此应该从小往大遍历，不断选取最短的两根木棒组成新木棒加入所需队列中，换个角度就是说：最短的木棒与次短的木棒应该是兄弟节点。&nbsp; 仔细领会错误和正确策略的区别（懒得开Visio了✧(≖ ◡ ≖✿)）：1+2拼成3，3+3拼成6，此时需要6、5、4三根木棒，6便是最大的，而不是从一开始受限的角度所得出的5。&nbsp;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n;int plank[20000];void slove() &#123; long long res = 0; while (n &amp;gt; 1) &#123; int min = 0; //最小的板的下标 int minNext = 1; //次小的板的下标 if (plank[min] &amp;gt; plank[minNext]) &#123; swap(min, minNext); &#125; for (int i = 2; i &amp;lt; n; i++) &#123; //找到最小和次小的两块板 if (plank[i] &amp;lt; plank[min]) &#123; minNext = min; min = i; &#125; else if (plank[i] &amp;lt; plank[minNext]) &#123; minNext = i; &#125; &#125; int t = plank[min] + plank[minNext]; res += t; if (min == n - 1) &#123; //将拼合后的板加入到数组中，去掉原来的 swap(min, minNext); &#125; plank[min] = t; plank[minNext] = plank[n - 1]; n--; &#125; cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; endl;&#125;int main() &#123; cin &amp;gt;&amp;gt; n; for (int i = 0; i &amp;lt; n; i++) &#123; cin &amp;gt;&amp;gt; plank[i]; &#125; slove(); return 0; &#125; &nbsp;","categories":[],"tags":[]},{"title":"POJ 3069 Saruman's Army 题解","slug":"poj-3069-sarumans-army","date":"2017-02-12T14:05:09.000Z","updated":"2017-12-09T15:31:04.409Z","comments":true,"path":"2017/02/12/poj-3069-sarumans-army/","link":"","permalink":"//carolunar.com/2017/02/12/poj-3069-sarumans-army/","excerpt":"","text":"POJ 3069 Saruman’s Army 书中例题，关键解法（区间去重）很典型，因此记下来。 我们从最左边开始考虑。对于这个点，到距其R以内的区域内必须要有带有标记的点。（此点位于最左边，所以显然）带有标记的这个点一定在此点右侧（包含这个点自身）。 于是，究竟要给哪个点加上标记呢？答案应该是从最左边的点开始，距离为R以内的最远的点，因为更左的区域没有覆盖的意义，所以应该尽可能覆盖更靠右的点。 如上所示（图），加上了第一个标记后，剩下的部分也用同样的办法处理。对于添加了符号的点右侧相距超过R的下一个点，采用同样的方法找到其右侧R距离以内最远的点添加标记。在所有的点都被覆盖之前不断重复这一过程。1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;&gt; #include &lt;algorithm&gt;&gt; &gt; using namespace std;&gt; &gt; int r;&gt; int n;&gt; int x[1000];&gt; &gt; void solve() &#123;&gt; int res = 0;&gt; sort(x, x + n);&gt; &gt; int i = 0;&gt; while (i &amp;lt; n) &#123;&gt; int s = x[i++];&gt; while (i &amp;lt; n &amp;amp;&amp;amp; x[i] &amp;lt;= s + r) &#123;&gt; i++;&gt; &#125;&gt; int p = x[i - 1];&gt; while (i &amp;lt; n &amp;amp;&amp;amp; x[i] &amp;lt;= p + r) &#123;&gt; i++;&gt; &#125;&gt; res++; &gt; &#125;&gt; cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; endl;&gt; &#125;&gt; &gt; int main() &#123;&gt; while (cin &amp;gt;&amp;gt; r &amp;gt;&amp;gt; n &amp;amp;&amp;amp; r != -1) &#123;&gt; for (int i = 0; i &amp;lt; n; i++) &#123;&gt; cin &amp;gt;&amp;gt; x[i];&gt; &#125;&gt; &gt; solve();&gt; &#125;&gt; return 0;&gt; &#125; &nbsp;","categories":[],"tags":[]},{"title":"AOJ 0033 Ball 题解","slug":"aoj-0033-ball","date":"2017-02-12T14:02:15.000Z","updated":"2017-12-09T15:31:04.301Z","comments":true,"path":"2017/02/12/aoj-0033-ball/","link":"","permalink":"//carolunar.com/2017/02/12/aoj-0033-ball/","excerpt":"AOJ 0033 Ball 思路：二进制枚举，用了昨天学到的2^N以及与运算方法枚举。","text":"AOJ 0033 Ball 思路：二进制枚举，用了昨天学到的2^N以及与运算方法枚举。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int n;int ball[10]; vector&lt;int&gt; l;vector&lt;int&gt; r;bool solve() &#123; bool res = false; for (int i = 0; i &amp;lt; 1024; i++) &#123; for (int j = 0; j &amp;lt; 10; j++) &#123; if (i &amp;amp; (1 &amp;lt;&amp;lt; j)) &#123; l.push_back(ball[j]); &#125; else &#123; r.push_back(ball[j]); &#125; &#125; int lLen = l.size(); int rLen = r.size(); bool lOK = true; bool rOK = true; for (int j = 0; j &amp;lt; lLen - 1; j++) &#123; if (l.at(j) &amp;gt; l.at(j + 1)) &#123; lOK = false; break; &#125; &#125; for (int j = 0; j &amp;lt; rLen - 1; j++) &#123; if (r.at(j) &amp;gt; r.at(j + 1)) &#123; rOK = false; break; &#125; &#125; if (lOK &amp;amp;&amp;amp; rOK) &#123; res = true; break; &#125; l.clear(); r.clear(); &#125; return res;&#125;int main() &#123; cin &amp;gt;&amp;gt; n; for (int i = 0; i &amp;lt; n; i++) &#123; for (int j = 0; j &amp;lt; 10; j++) &#123; cin &amp;gt;&amp;gt; ball[j]; &#125; if (solve()) &#123; cout &amp;lt;&amp;lt; \"YES\" &amp;lt;&amp;lt; endl; &#125; else &#123; cout &amp;lt;&amp;lt; \"NO\" &amp;lt;&amp;lt; endl; &#125; &#125; return 0;&#125; &nbsp;","categories":[],"tags":[]},{"title":"[转] AOJ 0525 Osenbei《挑战程序设计竞赛(第2版)》练习题答案","slug":"aoj-0525-osenbei","date":"2017-02-12T14:00:07.000Z","updated":"2017-12-09T15:31:04.395Z","comments":true,"path":"2017/02/12/aoj-0525-osenbei/","link":"","permalink":"//carolunar.com/2017/02/12/aoj-0525-osenbei/","excerpt":"","text":"来自 码农场 » AOJ 0525 Osenbei《挑战程序设计竞赛(第2版)》练习题答案 只把代码复制过来，原博的其他分析请看链接。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;bitset&gt;#include &lt;algorithm&gt;using namespace std;bitset&lt;10000&gt; cookie[10];///////////////////////////SubMain//////////////////////////////////int main(int argc, char *argv[])&#123; int R, C; while(cin &amp;gt;&amp;gt; R &amp;gt;&amp;gt; C &amp;amp;&amp;amp; R &amp;gt; 0) &#123; int i, j; for (i = 0; i &amp;lt; R; ++i) &#123; for (j = 0; j &amp;lt; C; ++j) &#123; bool upwards; cin &amp;gt;&amp;gt; upwards; cookie[i][j] = upwards; &#125; &#125; // 在横向一共有2^R种变换 int permute_r = 1 &amp;lt;&amp;lt; R; int result = 0; for (i = 0; i &amp;lt; permute_r ; ++i) &#123; // 完成当前的变换 for (j = 0; j &amp;lt; R; ++j) &#123; // 这一行是否应当翻个面 if (i &amp;amp; (1 &amp;lt;&amp;lt; j)) &#123; cookie[j].flip(); &#125; &#125; // 对每一列分别算出朝上和朝下的煎饼个数，取其最大值 int possible_answer = 0; for (j = 0; j &amp;lt; C; ++j) &#123; int up_cookie_count = 0; for (int k = 0; k &amp;lt; R; ++k) &#123; if (cookie[k][j]) &#123; ++up_cookie_count; &#125; &#125; possible_answer += max(up_cookie_count, R - up_cookie_count); &#125; // 结果取最大值 result = max(result, possible_answer); // 复原 for (j = 0; j &amp;lt; R; ++j) &#123; if (i &amp;amp; (1 &amp;lt;&amp;lt; j)) &#123; cookie[j].flip(); &#125; &#125; &#125; cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; endl; &#125; return 0;&#125; __总结的分割线__ 原博有一个很妙的写法，permute = 2^N，循环 permute 次，每次又根据 (i &amp; (1 &lt;&lt; j)) 为真来确定特定要翻转的煎饼，这样，用二重循环加一个if判断就可以代替任意N重循环。【手动插入“你太强啦”表情包】 bitset是个好东西，尖括号里写的不是数据类型，而是二进制的位数。 原博的写法是先定义了 int i,j ，以后的每次循环都直接用，和我的习惯不一样。我照着原博代码写的时候就发现了一个问题，经过测试如下： 1234567891011#include &lt;iostream&gt;using namespace std; int main() &#123; int i; for (i = 0; i &amp;lt; 3; i++) &#123; for (i = 0; i &amp;lt; 5; i++) &#123; cout &lt;&amp;lt; i; //--&gt;01234 &#125; &#125; return 0;&#125; using namespace std;123456789 int main() &#123; for (int i = 0; i &amp;lt; 3; i++) &#123; for (int i = 0; i &amp;lt; 5; i++) &#123; cout &lt;&amp;lt; i; //--&gt;012340123401234 &#125; &#125; return 0;&#125; 因此决定以后还是直接在for循环内定义变量，虽然麻烦点，但是减少了出错概率，以及不用想那么多变量名。","categories":[],"tags":[]},{"title":"POJ 3050 Hopscotch 题解","slug":"poj-3050-hopscotch-e9-a2-98-e8-a7-a3","date":"2017-02-12T13:55:22.000Z","updated":"2017-12-09T15:31:04.317Z","comments":true,"path":"2017/02/12/poj-3050-hopscotch-e9-a2-98-e8-a7-a3/","link":"","permalink":"//carolunar.com/2017/02/12/poj-3050-hopscotch-e9-a2-98-e8-a7-a3/","excerpt":"","text":"POJ 3050 Hopscotch 思路： 并无太好的…看了@Lorazepam的代码 原本的思路是用 vector 存放生成的整数，这样还需要在放进去之前把位数乘基数变成相应整数，而且需要对 vector 去重 然后才发现有 set 这一好用容器，插入值重复的话会插入失败，因此最后只要用 .size() 就可以得到所有的可能性了。并且不用bother to生成整数，直接当成字符串放进去就好了。 用DFS，网格上的每一点都依次作为起点开始深搜，每跳一步 n 就加 1，当 n 为 6 时，说明前面已经有 0~5 这 6 步了， 返回。 因为有 n 为 6 做限制，所以就算可以重复访问，也不会无限循环。 &nbsp; 还需进一步领会深搜和广搜的精神。12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;string&gt;using namespace std;int grid[5][5];int dx[4] = &#123;-1, 0, 1, 0&#125;;int dy[4] = &#123;0, -1, 0, 1&#125;;char digits[6];set&lt;string&gt; integers;void dfs(int x, int y, int n) &#123; if (n == 6) &#123; string temp = digits; integers.insert(temp); return; &#125; digits[n] = grid[x][y] + '0'; for (int i = 0; i &amp;lt; 4; i++) &#123; int nx = x + dx[i]; int ny = y + dy[i]; if (nx &amp;gt;= 0 &amp;amp;&amp;amp; nx &lt; 5 &amp;amp;&amp;amp; ny &gt;= 0 &amp;amp;&amp;amp; ny &amp;lt; 5) &#123; dfs(nx, ny, n + 1); &#125; &#125; &#125;int main() &#123; for (int i = 0; i &amp;lt; 5; i++) &#123; for (int j = 0; j &amp;lt; 5; j++) &#123; cin &amp;gt;&amp;gt; grid[i][j]; &#125; &#125; for (int i = 0; i &amp;lt; 5; i++) &#123; for (int j = 0; j &amp;lt; 5; j++) &#123; dfs(i, j, 0); &#125; &#125; cout &amp;lt;&amp;lt; integers.size(); return 0; &#125; &nbsp;","categories":[],"tags":[]},{"title":"POJ 3187 Backward Digit Sums 题解","slug":"poj-3187-backward-digit-sums","date":"2017-02-12T13:53:38.000Z","updated":"2017-12-09T15:31:04.370Z","comments":true,"path":"2017/02/12/poj-3187-backward-digit-sums/","link":"","permalink":"//carolunar.com/2017/02/12/poj-3187-backward-digit-sums/","excerpt":"","text":"POJ 3187 Backward Digit Sums 思路： 这道题很简单，用next_permutation枚举1~N的所有排列，然后依次相加，判断最后的和是否等于sum，是的话则break，即为字典序最前的。1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n;int sum;int mycase[11][11];int main() &#123; cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; sum; for (int i = 1; i &amp;lt;= n; i++) &#123; mycase[n][i] = i; &#125; do &#123; for (int i = n; i &amp;gt; 1; i--) &#123; for (int j = 1; j &amp;lt; i; j++) &#123; mycase[i - 1][j] = mycase[i][j] + mycase[i][j + 1]; &#125; &#125; if (mycase[1][1] == sum) &#123; for (int i = 1; i &amp;lt;= n; i++) &#123; cout &amp;lt;&amp;lt; mycase[n][i] &amp;lt;&amp;lt; \" \"; &#125; break; &#125; &#125; while (next_permutation(mycase[n] + 1, mycase[n] + 1 + n)); return 0;&#125; 注意： next_permutaiton(m, n)的两个参数分别是枚举起始的元素，和结束的元素的后一个元素。也就是区间为[m, n).","categories":[],"tags":[]},{"title":"POJ 3669 Meteor Shower 题解","slug":"poj-3669-meteor-shower","date":"2017-02-12T13:50:54.000Z","updated":"2017-12-09T15:33:26.928Z","comments":true,"path":"2017/02/12/poj-3669-meteor-shower/","link":"","permalink":"//carolunar.com/2017/02/12/poj-3669-meteor-shower/","excerpt":"POJ 3669 Meteor Shower 题意：这个同学发现流星雨要来了，会对地球造成伤害于是决定逃跑。N颗流星会不定时降落在坐标轴第一象限300*300内的点上。给出每颗流星降落的坐标和时刻，求这个同学能否成功逃跑，能的话用时多少。 思路：略有一点tricky，无法变通了(@﹏@)~。看了码农场的代码。 这道题没有给出地图，所以需要自己生成地图。 关键的点在于：在生成地图的时候，将每个点的初始值设为无穷大（表示不会有流星），将要被摧毁的点设置为流星降落的时刻。如果原点从一开始就被炸毁，那么直接死亡，否则开始BFS。 从原点开始广度优先地游荡，判断要不要到一个点的依据是该点在地图内，并且该点此前未被访问过，也未被炸毁（可能在将来被炸毁）。每到一个点，当前时间+1. 在游荡过程中一旦发现一个点永远不会被炸（&gt;last变量，或者等于INF？），说明找到了活命点，返回当前所用时间。 如果一直到遍历完毕都找不到这样的点，说明无法逃跑，返回-1。","text":"POJ 3669 Meteor Shower 题意：这个同学发现流星雨要来了，会对地球造成伤害于是决定逃跑。N颗流星会不定时降落在坐标轴第一象限300*300内的点上。给出每颗流星降落的坐标和时刻，求这个同学能否成功逃跑，能的话用时多少。 思路：略有一点tricky，无法变通了(@﹏@)~。看了码农场的代码。 这道题没有给出地图，所以需要自己生成地图。 关键的点在于：在生成地图的时候，将每个点的初始值设为无穷大（表示不会有流星），将要被摧毁的点设置为流星降落的时刻。如果原点从一开始就被炸毁，那么直接死亡，否则开始BFS。 从原点开始广度优先地游荡，判断要不要到一个点的依据是该点在地图内，并且该点此前未被访问过，也未被炸毁（可能在将来被炸毁）。每到一个点，当前时间+1. 在游荡过程中一旦发现一个点永远不会被炸（&gt;last变量，或者等于INF？），说明找到了活命点，返回当前所用时间。 如果一直到遍历完毕都找不到这样的点，说明无法逃跑，返回-1。 代码：刚开始提交的时候总是Runtime Error，de了半天发现input数组本应该是50000，设置成了5000……这种粗心的错误要少犯啊12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;stdio.h&gt;#include &lt;memory.h&gt;#include &lt;queue&gt;using namespace std;const int MAX_INDEX = 512;int eMap[MAX_INDEX][MAX_INDEX];bool visited[MAX_INDEX][MAX_INDEX];struct Meteor &#123; int x; int y; int t;&#125;;typedef Meteor P;Meteor input[50000];int n;int last = 0;int dx[5] = &#123;-1, 0, 1, 0, 0&#125;;int dy[5] = &#123;0, -1, 0, 1, 0&#125;;int bfs() &#123; memset(visited, 0, sizeof(visited)); queue&lt;P&gt; que; P cur; cur.x = 0; cur.y = 0; cur.t = 0; que.push(cur); while (que.size()) &#123; for (int i = 0; i &amp;lt; 4; i++) &#123; cur = que.front(); cur.x += dx[i]; cur.y += dy[i]; cur.t++; if (cur.x &amp;gt;= 0 &amp;amp;&amp;amp; cur.y &amp;gt;= 0 &amp;amp;&amp;amp; cur.t &amp;lt; eMap[cur.x][cur.y] &amp;amp;&amp;amp; !visited[cur.x][cur.y]) &#123; visited[cur.x][cur.y] = true; if (eMap[cur.x][cur.y] &amp;gt; last) &#123; return cur.t; &#125; que.push(cur); &#125; &#125; que.pop(); &#125; return -1;&#125;int main() &#123; cin &amp;gt;&amp;gt; n; for (int i = 0; i &amp;lt; n; i++) &#123; cin &amp;gt;&amp;gt; input[i].x &amp;gt;&amp;gt; input[i].y &amp;gt;&amp;gt; input[i].t; &#125; memset(eMap, 0x7f, sizeof(eMap)); //将地图上所有点的值设为极大值（按题意只需大于1000就可） for (int i = 0; i &amp;lt; n; i++) &#123; //创建地图 last = max(last, input[i].t); //last变量记录流星下落的最晚时间 for (int j = 0; j &amp;lt; 5; j++) &#123; int nx = input[i].x + dx[j]; int ny = input[i].y + dy[j]; if (nx &amp;gt;= 0 &amp;amp;&amp;amp; ny &amp;gt;= 0 &amp;amp;&amp;amp; eMap[nx][ny] &amp;gt; input[i].t) &#123; eMap[nx][ny] = input[i].t; &#125; &#125; &#125; if (eMap[0][0] == 0) &#123; return -1; &#125; else &#123; cout &amp;lt;&amp;lt; bfs() &amp;lt;&amp;lt; endl; &#125; return 0;&#125; 这段代码里的结构体变量Meteor，又被typedef为P，不是多此一举。是因为这个变量有两个用途： 1 接收输入流，此时x，y代表流星将要下落的坐标，t代表下落时刻； 2 在BFS的时候，标志该同学此时所处位置，此时x，y代表该同学当前坐标，t代表目前为止所花时间。 Brilliant！ 感觉自己并写不出来这样的代码…","categories":[],"tags":[]},{"title":"AOJ 0558 Cheese 题解","slug":"aoj-0558-cheese","date":"2017-02-12T13:44:32.000Z","updated":"2017-12-09T15:33:26.935Z","comments":true,"path":"2017/02/12/aoj-0558-cheese/","link":"","permalink":"//carolunar.com/2017/02/12/aoj-0558-cheese/","excerpt":"AOJ 0558 Cheese 题意在H * W的地图上有N个奶酪工厂，分别生产硬度为1-N的奶酪。有一只吃货老鼠准备从老鼠洞出发吃遍每一个工厂的奶酪。老鼠有一个体力值，初始时为1，每吃一个工厂的奶酪体力值增加1（每个工厂只能吃一次），且老鼠只能吃硬度不大于当前体力值的奶酪。老鼠从当前格走到相邻的无障碍物的格（上下左右）需要时间1单位，有障碍物的格不能走。走到工厂上时即可吃到该工厂的奶酪，吃奶酪时间不计。问吃遍所有奶酪最少用时。输入：第一行三个整数H(1 &lt;= H &lt;= 1000)、W(1 &lt;= W &lt;=1000)、N(1 &lt;= N &lt;= 9)，之后H行W列为地图， “.“为空地， ”X“为障碍物，”S“为老鼠洞， 1-N代表硬度为1-N的奶酪的工厂。 入力例 13 3 1S..…..1 出力例 14 入力例 24 5 2.X..1….X.XX.S.2.X. 出力例 212 入力例 310 10 9.X…X.S.X6..5X..X1X…XXXX..XX..9X…X.8.X2X..X3X…XX.X4..XX….7X..X..X..XX..X…X.XX....X……. 出力例 391 思路老鼠初始体力值为1，并且只能吃硬度不大于当前体力值的奶酪，每吃一个奶酪体力值增加1。有N个奶酪，硬度分别为1~N。说明老鼠只能按照1~N的顺序吃。比如有5个奶酪，硬度分别是1、2、3、4、5，老鼠只能按照这个顺序吃，吃完之后的体力值分别为2、3、4、5、6。 看起来复杂的条件实际上降低了搜索难度，只需将递增的数字当做终点逐个搜索，相当于正常的BFS循环N次。","text":"AOJ 0558 Cheese 题意在H * W的地图上有N个奶酪工厂，分别生产硬度为1-N的奶酪。有一只吃货老鼠准备从老鼠洞出发吃遍每一个工厂的奶酪。老鼠有一个体力值，初始时为1，每吃一个工厂的奶酪体力值增加1（每个工厂只能吃一次），且老鼠只能吃硬度不大于当前体力值的奶酪。老鼠从当前格走到相邻的无障碍物的格（上下左右）需要时间1单位，有障碍物的格不能走。走到工厂上时即可吃到该工厂的奶酪，吃奶酪时间不计。问吃遍所有奶酪最少用时。输入：第一行三个整数H(1 &lt;= H &lt;= 1000)、W(1 &lt;= W &lt;=1000)、N(1 &lt;= N &lt;= 9)，之后H行W列为地图， “.“为空地， ”X“为障碍物，”S“为老鼠洞， 1-N代表硬度为1-N的奶酪的工厂。 入力例 13 3 1S..…..1 出力例 14 入力例 24 5 2.X..1….X.XX.S.2.X. 出力例 212 入力例 310 10 9.X…X.S.X6..5X..X1X…XXXX..XX..9X…X.8.X2X..X3X…XX.X4..XX….7X..X..X..XX..X…X.XX....X……. 出力例 391 思路老鼠初始体力值为1，并且只能吃硬度不大于当前体力值的奶酪，每吃一个奶酪体力值增加1。有N个奶酪，硬度分别为1~N。说明老鼠只能按照1~N的顺序吃。比如有5个奶酪，硬度分别是1、2、3、4、5，老鼠只能按照这个顺序吃，吃完之后的体力值分别为2、3、4、5、6。 看起来复杂的条件实际上降低了搜索难度，只需将递增的数字当做终点逐个搜索，相当于正常的BFS循环N次。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;deque&gt;using namespace std;const int INF = 0x3f3f3f3f;typedef pair&lt;int, int&gt; P;int h, w, n;int sx, sy;int gx, gy;char cmap[1000][1000];int goalSum;int goal[10];int d[1000][1000];int dx[4] = &#123;-1, 0, 1, 0&#125;;int dy[4] = &#123;0, -1, 0, 1&#125;;int bfs() &#123; int res = 0; deque&lt;P&gt; que; for (int ci = 0; ci &amp;lt; n; ci++) &#123; //要进行n次循环，寻找n次终点，每次步数计入goal[i], 最后累加起来是res for (int i = 0; i &amp;lt; h; i++) &#123; for (int j = 0; j &amp;lt; w; j++) &#123; d[i][j] = INF; &#125; &#125; que.push_back(P(sx, sy)); d[sx][sy] = 0; while(que.size()) &#123; int x = que.front().first; int y = que.front().second; que.pop_front(); if ((int)cmap[x][y] == 49 + ci) &#123; goal[ci] = d[x][y]; sx = x; sy = y; break; &#125; for (int i = 0; i &amp;lt; 4; i++) &#123; int nx = x + dx[i]; int ny = y + dy[i]; if (nx &amp;gt;=0 &amp;amp;&amp;amp; nx &lt; h &amp;amp;&amp;amp; ny &gt;= 0 &amp;amp;&amp;amp; ny &amp;lt; w &amp;amp;&amp;amp; cmap[nx][ny] != 'X' &amp;amp;&amp;amp; d[nx][ny] == INF) &#123; que.push_back(P(nx, ny)); d[nx][ny] = d[x][y] + 1; &#125; &#125; &#125; que.clear(); res += goal[ci]; &#125; return res;&#125;int main() &#123; cin &amp;gt;&amp;gt; h &amp;gt;&amp;gt; w &amp;gt;&amp;gt; n; for (int i = 0; i &amp;lt; h; i++) &#123; for (int j = 0; j &amp;lt; w; j++) &#123; cin &amp;gt;&amp;gt; cmap[i][j]; if (cmap[i][j] == 'S') &#123; sx = i; sy = j; &#125; &#125; &#125; goalSum = bfs(); cout &amp;lt;&amp;lt; goalSum &amp;lt;&amp;lt; endl; //不换行会PE return 0;&#125; 通常 BFS 使用队列 queue 即可，这里由于多次循环 BFS，每次要清空队列，故用了 STL 的双端队列 deque，clear() 函数用来清空。 deque 常用函数有：front(), back(), push_front(), push_back(), pop_front(), pop_back()。头尾均可以访问、添加、删除。 d[x][y]在记录起点到某坐标的步数的同时，还起到标志该点是否被搜索过的作用。 queue的empty()函数不是用来清空的！是返回该队列是否为空&gt; &lt; (debug了很久(:зゝ∠))","categories":[],"tags":[]},{"title":"迷宫最短路径问题 题解","slug":"the-shorest-path-of-maze","date":"2017-02-12T13:36:39.000Z","updated":"2017-12-09T15:31:04.366Z","comments":true,"path":"2017/02/12/the-shorest-path-of-maze/","link":"","permalink":"//carolunar.com/2017/02/12/the-shorest-path-of-maze/","excerpt":"","text":"《挑战程序设计竞赛》2.1.5 例题 问题：给定一个大小为N×M的迷宫。迷宫由通道和墙壁组成，每一步可以向邻接的上下左右四格的通道移动。请求出从起点到终点所需的最小步数。请注意，本题假定从起点一定可以移动到终点。 限制条件：N, M ≦100 示例输入： 10 10 #S######.#……#..#.#.##.##.#.#…….. ##.##.####….#….#.#######.#….#…...####.###.….#…G# 示例输出： 2212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int m;int n;const int INF = 0x3f3f3f3f;char maze[100][100];int d[100][100];int sx, sy;int gx, gy;int dx[4] = &#123; -1, 0, 1, 0 &#125;;int dy[4] = &#123; 0, 1, 0, -1 &#125;;typedef pair&lt;int, int&gt; P;void bfs() &#123; queue&lt;P&gt; q; q.push(P(sx, sy)); d[sx][sy] = 0; while (q.size()) &#123; int x = q.front().first; int y = q.front().second; q.pop(); if (x == gx &amp;amp;&amp;amp; y == gy) &#123; break; &#125; for (int i = 0; i &amp;lt; 4; i++) &#123; int nx = x + dx[i]; int ny = y + dy[i]; if (nx &amp;gt;= 0 &amp;amp;&amp;amp; nx &lt; n &amp;amp;&amp;amp; ny &gt;= 0 &amp;amp;&amp;amp; ny &amp;lt; m &amp;amp;&amp;amp; maze[nx][ny] != '#' &amp;amp;&amp;amp; d[nx][ny] == INF) &#123; q.push(P(nx, ny)); d[nx][ny] = d[x][y] + 1; &#125; &#125; &#125;&#125;int main() &#123; cin &amp;gt;&amp;gt; m &amp;gt;&amp;gt; n; for (int i = 0; i &amp;lt; n; i++) &#123; for (int j = 0; j &amp;lt; m; j++) &#123; cin &amp;gt;&amp;gt; maze[i][j]; d[i][j] = INF; if (maze[i][j] == 'S') &#123; sx = i; sy = j; &#125; if (maze[i][j] == 'G') &#123; gx = i; gy = j; &#125; &#125; &#125; bfs(); cout &amp;lt;&amp;lt; d[gx][gy]; return 0;&#125; DFS一般直接利用系统栈（通过在代码中使用递归），而BFS需要自己维护一个队列","categories":[],"tags":[]},{"title":"POJ 3009 Curling 2.0 题解","slug":"poj-3009-curling-2-0","date":"2017-02-12T13:30:06.000Z","updated":"2017-12-09T15:31:04.403Z","comments":true,"path":"2017/02/12/poj-3009-curling-2-0/","link":"","permalink":"//carolunar.com/2017/02/12/poj-3009-curling-2-0/","excerpt":"","text":"POJ3009 Curling 2.0 思路：DFS + 回溯 //照着别人的代码写的，测试数据输出正确，但没有AC，没有找到原因 //经@Lorazepam 提示，下面这行代码的h和w写反了… 66 while(scanf(“%d %d”, &amp;h, &amp;w) != EOF)123456//每个地图有n种路线，每条路线都会改变地图，因此每次搜索完毕得到结果（goal）后，要复原地图//每次递归DFS，就代表碰到了墙，需改变路线，因此要 step + 1//每条路线所用步数不同，题目求最小步数，因此要 goal = min(goal, step) #include #include using namespace std; int w;int h;const int INF = 0x3f3f3f3f; //常用的无穷大常量int goal;int res[100];int sx;int sy;int dx[4] = {-1, 0, 1, 0};int dy[4] = {0, 1, 0, -1}; int board[25][25]; bool isNotOut(int x, int y) { if(x &lt; 0 || y &lt; 0 || x &gt;= h || y &gt;= w) { return false; } return true;} void dfs(int step, int x, int y) { int nx; int ny; if(step &amp;gt; 10) { return ; } for(int i = 0; i &amp;lt; 4; i++) { nx = x + dx[i]; ny = y + dy[i]; if(!isNotOut(nx, ny)) { continue; } if(board[nx][ny] == 1) { continue; } while(!board[nx][ny]) { nx += dx[i]; ny += dy[i]; if(!isNotOut(nx, ny)) { break; } } if(isNotOut(nx, ny)) { if(board[nx][ny] == 3) { goal = min(goal, step); } if(board[nx][ny] == 1) { board[nx][ny] = 0; dfs(step + 1, nx - dx[i], ny - dy[i]); board[nx][ny] = 1; } } } } int main() { int n = 0; while(scanf(“%d %d”, &amp;h, &amp;w) != EOF) { if(w == 0 &amp;&amp; h == 0) { break; } for(int i = 0; i &lt; h; i++) { for(int j = 0; j &lt; w; j++) { scanf(“%d”, &amp;board[i][j]); if(board[i][j] == 2) { sx = i; sy = j; board[i][j] = 0; } } } goal = INF; dfs(1, sx, sy); res[n] = goal; n++; } for (int i = 0; i &lt; n; i++) { if(res[i] != INF) { printf(“%d\\n”, res[i]); } else { printf(“-1\\n”); } } return 0;}``` 额外收获： while (scanf() != EOF) 或者 while (~scanf())，结合 if(w == 0 &amp;&amp; h == 0) break; 用来判断测试数据输入完毕","categories":[],"tags":[]},{"title":"POJ 1979 Red and Black 题解","slug":"poj-1979-red-and-black","date":"2017-02-12T13:05:44.000Z","updated":"2017-12-09T15:31:04.305Z","comments":true,"path":"2017/02/12/poj-1979-red-and-black/","link":"","permalink":"//carolunar.com/2017/02/12/poj-1979-red-and-black/","excerpt":"","text":"POJ 1979 Red and Black 题意矩形屋顶上被覆盖了 H * W 的红色和黑色的瓦片。小明一开始站在黑瓦上，他可以向上下左右四个方向的黑瓦移动，但红瓦不行。给出小明的初始位置，问他可以移动到的位置总共有多少个。 思路深度优先搜索 #include using namespace std; int w[100000000];int h[100000000];int res[100000000];char tiles[20][20]; void dfs(int index, int x, int y) { tiles[x][y] = ‘#’; int dx[4] = {-1, 0, 1, 0}; int dy[4] = {0, -1, 0, 1}; for (int i = 0; i &lt; 4; i++) { int nx = x + dx[i]; int ny = y + dy[i]; if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; h[index] &amp;&amp; ny &lt; w[index] &amp;&amp; tiles[nx][ny] == ‘.’) { res[index]++; dfs(index, nx, ny); } } return;} void solve(int index) { res[index] = 1; for (int i = 0; i &lt; h[index]; i++) { for (int j = 0; j &lt; w[index]; j++) { if (tiles[i][j] == ‘@’) { dfs(index, i, j); } } }}int main() { int index = 0; do { cin &gt;&gt; w[index] &gt;&gt; h[index]; for (int i = 0; i &lt; h[index]; i++) { for (int j = 0; j &lt; w[index]; j++) { cin &gt;&gt; tiles[i][j]; } } solve(index); index++; } while (w[index - 1] &gt; 0 &amp;&amp; h[index - 1] &gt; 0); for (int i = 0; i &amp;lt; index -1; i++) { cout &amp;lt;&amp;lt; res[i] &amp;lt;&amp;lt; endl; } return 0; }12345678//第一个AC的OJ题目，加油* * *## 2017.4.7 温习重写了一下 #include #include #define ONLINE_JUDGEusing namespace std;const int MAX_N = 20 + 4;int H;int W;char tile[MAX_N][MAX_N];int sx;int sy;int res;int dx[4] = {-1, 0, 1, 0};int dy[4] = {0, -1, 0, 1}; void dfs(int x, int y) { int nx; int ny; tile[x][y] = ‘#’; for (int i = 0; i &lt; 4; i++) { nx = x + dx[i]; ny = y + dy[i]; if (nx &gt;= 0 &amp;&amp; nx &lt; H &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; W &amp;&amp; tile[nx][ny] == ‘.’) { res++;// tile[nx][ny] = ‘#’; dfs(nx, ny); } } return;} int main() { #ifndef ONLINE_JUDGE freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); #endif while (scanf(&quot;%d %d&quot;, &amp;amp;W, &amp;amp;H) &amp;amp;&amp;amp; W != 0) { for (int i = 0; i &amp;lt; H; i++) { cin.ignore(); for (int j = 0; j &amp;lt; W; j++) { scanf(&quot;%c&quot;, &amp;amp;tile[i][j]); if (tile[i][j] == &apos;@&apos;) { sx = i; sy = j; tile[i][j] = &apos;.&apos;; } } } res = 1; dfs(sx, sy); printf(&quot;%d\\n&quot;, res); } #ifndef ONLINE_JUDGE fclose(stdin); #endif return 0; }``` &nbsp; 无需用数组保存各个用例的结果，在用例间直接输出就可以 注意状态的改变或者标记是在找到子递归的时候进行还是每次进入新递归之后进行 如果需要知道 dfs 的次数，那么应该在每次进行 dfs 的时候传递步数（如 POJ 3009）","categories":[],"tags":[]}]}